<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>M.A.R.A. - DIVISION 4 ARCADE</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --rabbit: #e8707e;
            --rabbit-glow: rgba(232, 112, 126, 0.3);
            --rabbit-subtle: rgba(232, 112, 126, 0.12);
            --cyan: #00ffff;
            --cyan-glow: rgba(0, 255, 255, 0.3);
            --gold: #ffd700;
            --bg-dark: #050510;
            --bg-card: rgba(0, 10, 20, 0.95);
            --text-primary: #ffffff;
            --text-dim: #888888;
            --border: rgba(232, 112, 126, 0.3);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        html, body {
            height: 100%;
            height: 100dvh;
            overflow: hidden;
        }
        
        body {
            background: var(--bg-dark);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            font-family: 'Space Mono', monospace;
            color: var(--text-primary);
            touch-action: none;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
            padding-top: max(4px, env(safe-area-inset-top));
            padding-bottom: max(4px, env(safe-area-inset-bottom));
            -webkit-font-smoothing: antialiased;
        }
        
        .game-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 400px;
            height: 100%;
            max-height: 100dvh;
        }
        
        /* Compact header */
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 8px 12px;
            font-size: 0.7rem;
            color: var(--rabbit);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            background: rgba(0, 5, 15, 0.95);
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }
        
        .game-header .weapon-info {
            color: var(--cyan);
            font-size: 0.65rem;
        }
        
        .lives-display {
            color: var(--rabbit);
            font-size: 0.75rem;
            letter-spacing: 2px;
        }
        
        /* Minimal title */
        .game-title {
            text-align: center;
            padding: 8px 0 6px;
            flex-shrink: 0;
        }
        
        .game-title h1 {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--rabbit);
            text-shadow: 0 0 20px var(--rabbit-glow);
            letter-spacing: 0.3em;
            margin-bottom: 2px;
        }
        
        .game-title .subtitle {
            font-size: 0.5rem;
            color: var(--text-dim);
            letter-spacing: 0.15em;
            font-weight: 400;
        }
        
        /* Canvas takes remaining space */
        .canvas-wrapper {
            position: relative;
            width: 100%;
            max-width: 400px;
            flex: 1;
            min-height: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #gameCanvas {
            display: block;
            max-width: 100%;
            max-height: 100%;
            border: 2px solid rgba(232, 112, 126, 0.3);
            background: var(--bg-dark);
        }
        
        /* CRT Effect Overlay */
        .crt-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            background: 
                repeating-linear-gradient(
                    0deg,
                    rgba(0, 0, 0, 0.08),
                    rgba(0, 0, 0, 0.08) 1px,
                    transparent 1px,
                    transparent 2px
                );
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           STAR WARS STYLE WEAPON SWITCH BUTTONS
           Horizontal, rectangular, digital blinking
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .side-weapon-btn {
            position: absolute;
            bottom: 15%;
            padding: 14px 18px;
            min-width: 90px;
            background: rgba(0, 20, 40, 0.85);
            border: 1px solid rgba(0, 255, 255, 0.4);
            color: rgba(0, 255, 255, 0.7);
            font-family: 'Space Mono', monospace;
            font-size: 0.7rem;
            font-weight: 700;
            letter-spacing: 0.1em;
            cursor: pointer;
            z-index: 10;
            transition: all 0.1s ease;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: 8px;
            text-transform: uppercase;
            box-shadow: 
                0 0 10px rgba(0, 255, 255, 0.1),
                inset 0 0 20px rgba(0, 255, 255, 0.05);
        }
        
        .side-weapon-btn::before {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.5), transparent);
            animation: scanline 2s linear infinite;
        }
        
        @keyframes scanline {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.8; }
        }
        
        @keyframes buttonBlink {
            0%, 90%, 100% { opacity: 1; }
            92%, 98% { opacity: 0.7; }
        }
        
        .side-weapon-btn {
            animation: buttonBlink 3s ease-in-out infinite;
        }
        
        .side-weapon-btn:active {
            background: rgba(0, 255, 255, 0.25);
            color: #00ffff;
            border-color: #00ffff;
            box-shadow: 
                0 0 20px rgba(0, 255, 255, 0.4),
                inset 0 0 30px rgba(0, 255, 255, 0.15);
            transform: scale(0.97);
        }
        
        .side-weapon-btn.left-side {
            left: 5px;
            border-radius: 4px;
        }
        
        .side-weapon-btn.right-side {
            right: 5px;
            border-radius: 4px;
        }
        
        .side-weapon-btn .arrow {
            font-size: 1rem;
            line-height: 1;
        }
        
        .side-weapon-label {
            font-size: 0.6rem;
            letter-spacing: 0.05em;
            font-weight: 400;
        }
        }
        
        /* Hide side buttons on desktop (they have keyboard) */
        @media (min-width: 501px) {
            .side-weapon-btn { display: none; }
        }
        
        /* Mobile Controls - compact for Instagram browser */
        .mobile-controls {
            display: flex;
            width: 100%;
            max-width: 400px;
            gap: 8px;
            padding: 8px;
            box-sizing: border-box;
            flex-shrink: 0;
            background: rgba(0, 5, 15, 0.5);
        }
        
        .control-btn {
            background: rgba(232, 112, 126, 0.1);
            border: 1px solid var(--rabbit);
            color: var(--rabbit);
            font-family: 'Space Mono', monospace;
            font-weight: 700;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.1s ease;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            box-shadow: 0 0 15px rgba(232, 112, 126, 0.1);
        }
        
        .control-btn:active, .control-btn.active {
            background: rgba(232, 112, 126, 0.35);
            transform: scale(0.97);
            box-shadow: 0 0 25px rgba(232, 112, 126, 0.3);
        }
        
        /* Big movement buttons on sides */
        .move-btn {
            flex: 1;
            height: 72px;
            font-size: 2rem;
        }
        
        /* Bomb button in center */
        .bomb-btn {
            flex: 0.7;
            height: 72px;
            background: rgba(255, 215, 0, 0.1);
            border-color: var(--gold);
            color: var(--gold);
            flex-direction: column;
            gap: 2px;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.1);
        }
        
        .bomb-btn .btn-label {
            font-size: 0.65rem;
            letter-spacing: 0.1em;
        }
        
        .bomb-btn .btn-icon {
            font-size: 0.8rem;
        }
        
        .bomb-btn:active {
            background: rgba(255, 215, 0, 0.35);
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.3);
        }
        
        .bomb-btn:disabled {
            opacity: 0.3;
            border-color: #333;
            color: #333;
            box-shadow: none;
        }
        
        /* Desktop controls hint */
        .desktop-controls {
            margin-top: 10px;
            text-align: center;
            color: var(--text-dim);
            font-size: 0.6rem;
            letter-spacing: 0.1em;
        }
        
        @media (max-width: 500px) {
            .desktop-controls { display: none; }
        }
        
        @media (min-width: 501px) {
            .mobile-controls { display: none; }
        }
        
        /* Start Screen */
        .overlay-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            padding: 15px;
        }
        
        .overlay-screen.hidden {
            display: none;
        }
        
        .overlay-screen h2 {
            font-size: 22px;
            color: #e8707e;
            text-shadow: 0 0 30px rgba(232, 112, 126, 0.8);
            letter-spacing: 6px;
            margin-bottom: 10px;
        }
        
        .overlay-screen .logo {
            font-size: 40px;
            margin-bottom: 15px;
        }
        
        .overlay-screen p {
            color: #666;
            font-size: 10px;
            letter-spacing: 2px;
            margin-bottom: 6px;
            text-align: center;
        }
        
        /* Start Screen */
        .overlay-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(180deg, rgba(5, 5, 20, 0.98) 0%, rgba(10, 5, 15, 0.98) 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            padding: 20px;
        }
        
        .overlay-screen.hidden {
            display: none;
        }
        
        .overlay-screen h2 {
            font-size: 1.4rem;
            font-weight: 700;
            color: var(--rabbit);
            text-shadow: 0 0 30px var(--rabbit-glow);
            letter-spacing: 0.3em;
            margin-bottom: 8px;
        }
        
        .overlay-screen .logo {
            font-size: 2.5rem;
            margin-bottom: 12px;
            filter: drop-shadow(0 0 10px var(--rabbit-glow));
        }
        
        .overlay-screen p {
            color: var(--text-dim);
            font-size: 0.65rem;
            letter-spacing: 0.15em;
            margin-bottom: 6px;
            text-align: center;
            font-weight: 400;
        }
        
        .overlay-screen .blink {
            animation: blink 1s step-end infinite;
            color: var(--text-primary);
            margin-top: 20px;
            font-size: 0.75rem;
            letter-spacing: 0.1em;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }
        
        .overlay-screen .story {
            max-width: 320px;
            text-align: center;
            color: var(--text-dim);
            font-size: 0.7rem;
            line-height: 1.8;
            margin: 16px 0;
            padding: 16px 20px;
            background: rgba(232, 112, 126, 0.05);
            border: 1px solid var(--border);
            border-radius: 4px;
        }
        
        .overlay-screen .controls-info {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 12px;
            margin-top: 16px;
            font-size: 0.55rem;
            color: var(--text-dim);
            letter-spacing: 0.05em;
        }
        
        .controls-info div {
            text-align: center;
            padding: 10px 14px;
            background: rgba(0, 255, 255, 0.03);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 4px;
            min-width: 60px;
        }
        
        .controls-info span {
            color: var(--cyan);
            display: block;
            font-size: 0.9rem;
            font-weight: 700;
            margin-bottom: 4px;
            letter-spacing: 0.1em;
        }
        
        .victory h2 {
            color: #00ff88 !important;
            text-shadow: 0 0 30px rgba(0, 255, 136, 0.5) !important;
        }
        
        .game-btn {
            margin-top: 20px;
            padding: 14px 40px;
            background: rgba(232, 112, 126, 0.1);
            border: 1px solid var(--rabbit);
            color: var(--rabbit);
            font-family: 'Space Mono', monospace;
            font-size: 0.8rem;
            font-weight: 700;
            cursor: pointer;
            letter-spacing: 0.15em;
            transition: all 0.2s ease;
            text-shadow: 0 0 10px var(--rabbit-glow);
            box-shadow: 0 0 20px rgba(232, 112, 126, 0.1);
        }
        
        .game-btn:hover, .game-btn:active {
            background: rgba(232, 112, 126, 0.25);
            box-shadow: 0 0 30px rgba(232, 112, 126, 0.3);
            transform: scale(0.98);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-title">
            <h1>M.A.R.A.</h1>
            <div class="subtitle">MAMMALIAN ASSAULT RESISTANCE ARCADE</div>
        </div>
        
        <div class="game-header">
            <div>SCORE: <span id="score">0</span></div>
            <div class="weapon-info" id="weaponDisplay">BEAM LV.1</div>
            <div>WAVE: <span id="wave">1</span></div>
            <div class="lives-display" id="livesDisplay">â™¥â™¥â™¥â™¥â™¥</div>
        </div>
        
        <div class="canvas-wrapper">
            <canvas id="gameCanvas" width="400" height="500"></canvas>
            <div class="crt-overlay"></div>
            
            <!-- Side weapon switch buttons -->
            <button class="side-weapon-btn left-side" id="weaponBtnLeft"><span class="arrow">â—€</span><span class="side-weapon-label" id="weaponLabelLeft">HOMING</span></button>
            <button class="side-weapon-btn right-side" id="weaponBtnRight"><span class="side-weapon-label" id="weaponLabelRight">LASER</span><span class="arrow">â–¶</span></button>
            
            <!-- Start Screen -->
            <div class="overlay-screen" id="startScreen">
                <div class="logo">ğŸ°</div>
                <h2>M.A.R.A.</h2>
                <p>MAMMALIAN ASSAULT RESISTANCE ARCADE</p>
                <div class="story">
                    <span style="color: var(--rabbit);">DIVISION 4 HAS FALLEN.</span><br><br>
                    The horses have taken control.<br>
                    You are the last line of defense.<br><br>
                    <span style="color: var(--cyan);">â—†</span> Defeat 3 waves of enemies<br>
                    <span style="color: var(--cyan);">â—†</span> Destroy the Mini-Boss<br>
                    <span style="color: var(--cyan);">â—†</span> Conquer 4 Main Bosses<br><br>
                    <span style="color: var(--rabbit);">â™¥</span> Collect hearts for extra lives<br>
                    <span style="color: var(--gold);">â˜…</span> Grab power-ups to upgrade weapons
                </div>
                <div class="controls-info">
                    <div><span>â—€ â–¶</span>MOVE</div>
                    <div><span>AUTO</span>FIRE</div>
                    <div><span>ğŸ’¥</span>BOMB</div>
                    <div><span>âŸ¨ âŸ©</span>WEAPON</div>
                </div>
                <p class="blink">[ TAP ANYWHERE TO BEGIN ]</p>
            </div>
            
            <!-- Game Over Screen -->
            <div class="overlay-screen hidden" id="gameOverScreen">
                <div class="logo">ğŸ’€</div>
                <h2>GAME OVER</h2>
                <p style="color: var(--rabbit); font-size: 0.9rem; margin: 10px 0;">SCORE: <span id="finalScore">0</span></p>
                <p>The horses prevail... for now.</p>
                <button class="game-btn" onclick="restartGame()">TRY AGAIN</button>
            </div>
            
            <!-- Victory Screen -->
            <div class="overlay-screen victory hidden" id="victoryScreen">
                <div class="logo">ğŸ†</div>
                <h2>ULTIMATE VICTORY!</h2>
                <p style="color: #00ff88; font-size: 0.9rem; margin: 10px 0;">SCORE: <span id="victoryScore">0</span></p>
                <p>ALL 4 HORSE BOSSES DEFEATED!</p>
                <p style="color: var(--rabbit);">THE RABBITS ARE FREE!</p>
                <button class="game-btn" onclick="restartGame()">PLAY AGAIN</button>
            </div>
        </div>
        
        <!-- Mobile Controls -->
        <div class="mobile-controls">
            <button class="control-btn move-btn" id="leftBtn">â—€</button>
            <button class="control-btn bomb-btn" id="specialBtn">
                <span class="btn-label">BOMB</span>
                <span class="btn-icon" id="specialCount">Ã—3</span>
            </button>
            <button class="control-btn move-btn" id="rightBtn">â–¶</button>
        </div>
        
        <div class="desktop-controls">
            â† â†’ MOVE | SPACE = BOMB | 1-4 = SWITCH WEAPON
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GAME STATE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let gameStarted = false;
        let gameOver = false;
        let victory = false;
        let score = 0;
        let lives = 5;
        let wave = 1;
        let bossActive = false;
        let lastTime = 0;
        let autoFireTimer = 0;
        
        // Main boss system - 4 main bosses after mini-boss
        let mainBossLevel = 0; // 0 = no main boss yet, 1-4 = current main boss
        let gameSpeed = 1.0; // Increases 10% after each main boss
        const MAX_MAIN_BOSSES = 4;
        const MAIN_BOSS_NAMES = ['STANDING STALLION', 'GALLOPING FURY', 'BABY TERROR', 'BASKETBALL BEAST'];
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STARFIELD BACKGROUND
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const stars = [];
        for (let i = 0; i < 100; i++) {
            stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 2 + 0.5,
                speed: Math.random() * 0.7 + 0.2,
                brightness: Math.random() * 0.5 + 0.3
            });
        }
        
        function updateStars() {
            stars.forEach(star => {
                star.y += star.speed;
                if (star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
            });
        }
        
        function drawStars() {
            stars.forEach(star => {
                ctx.fillStyle = `rgba(255, 255, 255, ${star.brightness})`;
                ctx.fillRect(star.x, star.y, star.size, star.size);
            });
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // WEAPON SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const WEAPONS = {
            BEAM: { name: 'BEAM', color: '#00ffff', fireRate: 200 },
            LASER: { name: 'LASER', color: '#ff00ff', fireRate: 65 },
            SPREAD: { name: 'SPREAD', color: '#ffff00', fireRate: 260 },
            HOMING: { name: 'HOMING', color: '#00ff00', fireRate: 400 }
        };
        
        let currentWeapon = 'BEAM';
        // Each weapon has its own level!
        let weaponLevels = {
            BEAM: 1,
            LASER: 1,
            SPREAD: 1,
            HOMING: 1
        };
        let specialAttacks = 3;
        let shields = 0; // Max 3 shields
        
        // Helper to get current weapon's level
        function getWeaponLevel() {
            return weaponLevels[currentWeapon];
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PLAYER
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const player = {
            x: 200,
            y: 470,
            width: 30,
            height: 30,
            speed: 4
        };
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BULLETS & EFFECTS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let playerBullets = [];
        let enemyBullets = [];
        let powerUps = [];
        let particles = [];
        let laserActive = false;
        let laserWidth = 0;
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ENEMIES
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let enemies = [];
        let boss = null;
        const PAWN = 'pawn';
        const KNIGHT = 'knight';
        const BUBBLE_SHOOTER = 'bubble'; // New enemy type
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // INPUT
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const keys = { left: false, right: false, special: false };
        let specialReady = true;
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // POWER-UP TYPES
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const POWERUP_TYPES = ['BEAM', 'LASER', 'SPREAD', 'HOMING', 'LEVELUP', 'SPECIAL', 'SHIELD', 'HEART'];
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // INITIALIZE WAVE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function initWave(waveNum) {
            enemies = [];
            enemyBullets = [];
            bossActive = false;
            boss = null;
            
            // Wave 1-3: Regular enemies
            // Wave 4: Mini-boss (Horse King)
            // Wave 5+: Main bosses (4 different ones)
            
            if (waveNum <= 3) {
                // Regular waves with increasing difficulty
                const rows = Math.min(2 + waveNum, 4);
                const cols = 7;
                
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        const type = row < 1 ? KNIGHT : PAWN;
                        const hasPowerUp = Math.random() < 0.22;
                        enemies.push({
                            x: 40 + col * 48,
                            y: 30 + row * 32,
                            width: type === KNIGHT ? 22 : 16,
                            height: type === KNIGHT ? 22 : 20,
                            type: type,
                            health: type === KNIGHT ? 4 : 2,
                            points: type === KNIGHT ? 20 : 10,
                            hasPowerUp: hasPowerUp,
                            moveDir: 1
                        });
                    }
                }
                
                // Add bubble shooters after wave 2
                if (waveNum >= 2) {
                    const bubbleCount = waveNum;
                    for (let i = 0; i < bubbleCount; i++) {
                        enemies.push({
                            x: 80 + i * 120,
                            y: 18,
                            width: 24,
                            height: 24,
                            type: BUBBLE_SHOOTER,
                            health: 5,
                            points: 30,
                            hasPowerUp: true,
                            moveDir: 1
                        });
                    }
                }
            } else if (waveNum === 4) {
                // Mini-boss wave (original Horse King)
                bossActive = true;
                boss = {
                    x: 200,
                    y: 55,
                    width: 80,
                    height: 70,
                    health: 150,
                    maxHealth: 150,
                    speed: 0.75 * gameSpeed,
                    direction: 1,
                    points: 1000,
                    attackTimer: 0,
                    shootsBubbles: true,
                    type: 'miniboss'
                };
                
                // Minions
                for (let i = 0; i < 5; i++) {
                    enemies.push({
                        x: 50 + i * 70,
                        y: 140,
                        width: 16,
                        height: 20,
                        type: PAWN,
                        health: 2,
                        points: 10,
                        hasPowerUp: i === 2,
                        moveDir: 1
                    });
                }
                
                // Bubble shooters
                for (let i = 0; i < 2; i++) {
                    enemies.push({
                        x: 100 + i * 200,
                        y: 120,
                        width: 24,
                        height: 24,
                        type: BUBBLE_SHOOTER,
                        health: 5,
                        points: 30,
                        hasPowerUp: true,
                        moveDir: 1
                    });
                }
            } else {
                // Main boss waves (5, 6, 7, 8)
                mainBossLevel = waveNum - 4; // 1, 2, 3, or 4
                bossActive = true;
                
                // Each main boss is harder
                const bossHP = [200, 280, 350, 500][mainBossLevel - 1];
                const bossSpeed = [0.8, 1.0, 1.1, 1.3][mainBossLevel - 1] * gameSpeed;
                const bossPoints = [2000, 3000, 4000, 5000][mainBossLevel - 1];
                
                boss = {
                    x: 200,
                    y: 70,
                    width: 100,
                    height: 80,
                    health: bossHP,
                    maxHealth: bossHP,
                    speed: bossSpeed,
                    direction: 1,
                    points: bossPoints,
                    attackTimer: 0,
                    shootsBubbles: true,
                    type: 'mainboss',
                    bossNum: mainBossLevel,
                    animTimer: 0,
                    legPhase: 0
                };
                
                // More minions for main bosses
                const minionCount = 4 + mainBossLevel * 2;
                for (let i = 0; i < minionCount; i++) {
                    enemies.push({
                        x: 30 + (i % 7) * 50,
                        y: 160 + Math.floor(i / 7) * 35,
                        width: 16,
                        height: 20,
                        type: Math.random() < 0.3 ? KNIGHT : PAWN,
                        health: Math.random() < 0.3 ? 4 : 2,
                        points: Math.random() < 0.3 ? 20 : 10,
                        hasPowerUp: Math.random() < 0.3,
                        moveDir: 1
                    });
                }
                
                // More bubble shooters
                for (let i = 0; i < mainBossLevel; i++) {
                    enemies.push({
                        x: 80 + i * 100,
                        y: 130,
                        width: 24,
                        height: 24,
                        type: BUBBLE_SHOOTER,
                        health: 5,
                        points: 30,
                        hasPowerUp: true,
                        moveDir: 1
                    });
                }
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // WEAPON FIRING
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function fireWeapon() {
            const weapon = WEAPONS[currentWeapon];
            
            switch(currentWeapon) {
                case 'BEAM':
                    fireBeam();
                    break;
                case 'LASER':
                    fireLaser();
                    break;
                case 'SPREAD':
                    fireSpread();
                    break;
                case 'HOMING':
                    fireHoming();
                    break;
            }
        }
        
        function fireBeam() {
            // Level 1: 1 beam, Level 2-3: 2 beams, Level 4-5: 3 beams, Level 6-7: 5 beams
            const level = getWeaponLevel();
            let positions;
            if (level <= 1) positions = [0];
            else if (level <= 3) positions = [-10, 10];
            else if (level <= 5) positions = [-15, 0, 15];
            else positions = [-20, -10, 0, 10, 20];
            
            // Damage scales: 1, 1, 2, 2, 3, 3, 4
            const damage = Math.floor((level + 1) / 2);
            
            positions.forEach(offset => {
                playerBullets.push({
                    x: player.x + offset,
                    y: player.y - 20,
                    speed: 7 + level * 0.3,
                    type: 'beam',
                    damage: damage,
                    color: '#00ffff'
                });
            });
        }
        
        function fireLaser() {
            // Continuous laser beam - width and damage scale with level
            const level = getWeaponLevel();
            laserActive = true;
            laserWidth = level * 3 + 4;
        }
        
        function fireSpread() {
            // More bullets and wider spread at higher levels
            const level = getWeaponLevel();
            let angles;
            if (level <= 1) angles = [-0.15, 0, 0.15];
            else if (level <= 2) angles = [-0.25, -0.08, 0.08, 0.25];
            else if (level <= 3) angles = [-0.35, -0.17, 0, 0.17, 0.35];
            else if (level <= 4) angles = [-0.4, -0.24, -0.08, 0.08, 0.24, 0.4];
            else if (level <= 5) angles = [-0.45, -0.3, -0.15, 0, 0.15, 0.3, 0.45];
            else if (level <= 6) angles = [-0.5, -0.35, -0.2, -0.05, 0.05, 0.2, 0.35, 0.5];
            else angles = [-0.55, -0.4, -0.25, -0.1, 0, 0.1, 0.25, 0.4, 0.55];
            
            const damage = Math.floor((level + 1) / 2);
            
            angles.forEach(angle => {
                playerBullets.push({
                    x: player.x,
                    y: player.y - 20,
                    speed: 6 + level * 0.2,
                    dx: Math.sin(angle) * (3 + level * 0.3),
                    type: 'spread',
                    damage: damage,
                    color: '#ffff00'
                });
            });
        }
        
        function fireHoming() {
            // More missiles at higher levels, damage scales too
            const level = getWeaponLevel();
            const count = Math.min(level, 5); // Max 5 missiles
            const damage = 1 + Math.floor(level / 2); // 1, 1, 2, 2, 3, 3, 4
            
            for (let i = 0; i < count; i++) {
                playerBullets.push({
                    x: player.x + (i - (count-1)/2) * 12,
                    y: player.y - 20,
                    speed: 4.5 + level * 0.3,
                    type: 'homing',
                    damage: damage,
                    color: '#00ff00',
                    target: null
                });
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SPECIAL ATTACK
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function useSpecialAttack() {
            if (specialAttacks <= 0 || !specialReady) return;
            
            specialAttacks--;
            specialReady = false;
            document.getElementById('specialCount').textContent = 'Ã—' + specialAttacks;
            if (specialAttacks <= 0) {
                document.getElementById('specialBtn').disabled = true;
            }
            
            // Screen flash
            particles.push({
                type: 'flash',
                alpha: 1,
                duration: 20
            });
            
            // Damage all enemies - kill up to 3
            let killCount = 0;
            for (let i = enemies.length - 1; i >= 0 && killCount < 3; i--) {
                const enemy = enemies[i];
                spawnParticles(enemy.x, enemy.y, '#ff0');
                score += enemy.points;
                if (enemy.hasPowerUp) spawnPowerUp(enemy.x, enemy.y);
                enemies.splice(i, 1);
                killCount++;
            }
            
            // Damage boss
            if (boss) {
                boss.health -= 10;
                spawnParticles(boss.x, boss.y, '#ff0');
                if (boss.health <= 0) {
                    score += boss.points;
                    
                    // Check if this was a main boss - increase game speed
                    if (boss.type === 'mainboss') {
                        gameSpeed += 0.1;
                        showNotification('SPEED UP! ' + Math.round(gameSpeed * 100) + '%', '#ff6600');
                    }
                    
                    boss = null;
                    bossActive = false;
                    
                    // Progress to next wave
                    wave++;
                    if (wave > 8) {
                        showVictory();
                    } else {
                        if (wave >= 5) {
                            showNotification('BOSS ' + (wave - 5) + '/4 DEFEATED!', '#00ff00');
                        }
                        updateUI();
                        setTimeout(() => initWave(wave), 1500);
                    }
                }
            }
            
            setTimeout(() => specialReady = true, 1000);
            updateUI();
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // POWER-UPS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function spawnPowerUp(x, y) {
            // Weighted distribution - LASER is rarer, LEVELUP is common, SHIELD added
            const weights = {
                'BEAM': 10,
                'LASER': 4,      // Very rare
                'SPREAD': 10,
                'HOMING': 10,
                'LEVELUP': 28,   // Most common - players need upgrades!
                'SPECIAL': 10,
                'SHIELD': 16,    // Fairly common - helps survival
                'HEART': 12     // Life recovery
            };
            
            const totalWeight = Object.values(weights).reduce((a, b) => a + b, 0);
            let random = Math.random() * totalWeight;
            let type = 'LEVELUP';
            
            for (const [powerType, weight] of Object.entries(weights)) {
                random -= weight;
                if (random <= 0) {
                    type = powerType;
                    break;
                }
            }
            powerUps.push({
                x: x,
                y: y,
                type: type,
                speed: 1.1,
                size: 28
            });
        }
        
        function collectPowerUp(powerUp) {
            switch(powerUp.type) {
                case 'BEAM':
                case 'LASER':
                case 'SPREAD':
                case 'HOMING':
                    // Level up that weapon (even if not equipped!)
                    if (weaponLevels[powerUp.type] < 7) {
                        weaponLevels[powerUp.type]++;
                        showNotification(powerUp.type + ' LV.' + weaponLevels[powerUp.type] + '!', getPowerUpColor(powerUp.type));
                    } else {
                        showNotification(powerUp.type + ' MAX!', getPowerUpColor(powerUp.type));
                    }
                    break;
                case 'LEVELUP':
                    // Level up current weapon
                    if (weaponLevels[currentWeapon] < 7) {
                        weaponLevels[currentWeapon]++;
                        showNotification(currentWeapon + ' LV.' + weaponLevels[currentWeapon] + '!', '#ffffff');
                    }
                    break;
                case 'SPECIAL':
                    specialAttacks = Math.min(specialAttacks + 1, 5);
                    document.getElementById('specialCount').textContent = 'Ã—' + specialAttacks;
                    document.getElementById('specialBtn').disabled = false;
                    showNotification('+1 BOMB!', '#ffd700');
                    break;
                case 'SHIELD':
                    if (shields < 3) {
                        shields++;
                        showNotification('+SHIELD! (' + shields + '/3)', '#00aaff');
                    } else {
                        // Convert to points if maxed
                        score += 100;
                        showNotification('+100 PTS!', '#00aaff');
                    }
                    break;
                case 'HEART':
                    lives++;
                    showNotification('+1 LIFE!', '#ff6b9d');
                    break;
            }
            spawnParticles(powerUp.x, powerUp.y, getPowerUpColor(powerUp.type));
            updateUI();
        }
        
        // Switch to next weapon
        function switchWeapon(direction = 1) {
            const weaponOrder = ['BEAM', 'LASER', 'SPREAD', 'HOMING'];
            let idx = weaponOrder.indexOf(currentWeapon);
            idx = (idx + direction + 4) % 4;
            currentWeapon = weaponOrder[idx];
            showNotification(currentWeapon + ' LV.' + weaponLevels[currentWeapon], WEAPONS[currentWeapon].color);
            updateUI();
            updateWeaponButton();
        }
        
        function updateWeaponButton() {
            // Update side button labels to show prev/next weapons
            const weaponOrder = ['BEAM', 'LASER', 'SPREAD', 'HOMING'];
            let idx = weaponOrder.indexOf(currentWeapon);
            const prevWeapon = weaponOrder[(idx - 1 + 4) % 4];
            const nextWeapon = weaponOrder[(idx + 1) % 4];
            
            const leftLabel = document.getElementById('weaponLabelLeft');
            const rightLabel = document.getElementById('weaponLabelRight');
            if (leftLabel) leftLabel.textContent = prevWeapon;
            if (rightLabel) rightLabel.textContent = nextWeapon;
        }
        
        // Notification system
        let notifications = [];
        
        function showNotification(text, color) {
            notifications.push({
                text: text,
                color: color,
                y: player.y - 50,
                alpha: 1,
                life: 60
            });
        }
        
        function updateNotifications() {
            notifications = notifications.filter(n => {
                n.y -= 1;
                n.life--;
                n.alpha = n.life / 60;
                return n.life > 0;
            });
        }
        
        function drawNotifications() {
            notifications.forEach(n => {
                ctx.save();
                ctx.globalAlpha = n.alpha;
                ctx.fillStyle = n.color;
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.font = 'bold 16px Courier New';
                ctx.textAlign = 'center';
                ctx.strokeText(n.text, player.x, n.y);
                ctx.fillText(n.text, player.x, n.y);
                ctx.restore();
            });
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PARTICLES
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function spawnParticles(x, y, color) {
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x: x,
                    y: y,
                    dx: (Math.random() - 0.5) * 6,
                    dy: (Math.random() - 0.5) * 6,
                    life: 20,
                    color: color,
                    type: 'particle'
                });
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DRAWING FUNCTIONS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function drawPlayer() {
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.scale(0.6, 0.6); // Make ship smaller
            
            // Engine flame (animated)
            const flameFlicker = Math.sin(Date.now() / 50) * 3;
            ctx.fillStyle = '#ff6600';
            ctx.beginPath();
            ctx.moveTo(-6, 15);
            ctx.lineTo(0, 25 + flameFlicker);
            ctx.lineTo(6, 15);
            ctx.closePath();
            ctx.fill();
            
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            ctx.moveTo(-3, 15);
            ctx.lineTo(0, 20 + flameFlicker * 0.5);
            ctx.lineTo(3, 15);
            ctx.closePath();
            ctx.fill();
            
            // Rocket body glow
            ctx.shadowColor = '#e8707e';
            ctx.shadowBlur = 12;
            
            // Rocket body (main hull)
            ctx.fillStyle = '#e8707e';
            ctx.beginPath();
            ctx.moveTo(0, -20);  // Nose
            ctx.quadraticCurveTo(12, -5, 10, 15);  // Right curve
            ctx.lineTo(-10, 15);  // Bottom
            ctx.quadraticCurveTo(-12, -5, 0, -20);  // Left curve
            ctx.closePath();
            ctx.fill();
            
            // Rocket fins
            ctx.fillStyle = '#c85a68';
            ctx.beginPath();
            ctx.moveTo(-10, 8);
            ctx.lineTo(-16, 18);
            ctx.lineTo(-8, 15);
            ctx.closePath();
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(10, 8);
            ctx.lineTo(16, 18);
            ctx.lineTo(8, 15);
            ctx.closePath();
            ctx.fill();
            
            // Bunny ears!
            ctx.fillStyle = '#e8707e';
            ctx.beginPath();
            ctx.ellipse(-6, -28, 4, 12, -0.15, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(6, -28, 4, 12, 0.15, 0, Math.PI * 2);
            ctx.fill();
            
            // Inner ears (pink)
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#ffb6c1';
            ctx.beginPath();
            ctx.ellipse(-6, -26, 2, 7, -0.15, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(6, -26, 2, 7, 0.15, 0, Math.PI * 2);
            ctx.fill();
            
            // Window / cockpit
            ctx.fillStyle = '#87ceeb';
            ctx.strokeStyle = '#5f9ea0';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(0, -5, 5, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Window shine
            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            ctx.beginPath();
            ctx.ellipse(-2, -7, 2, 2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        function drawPawn(x, y) {
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(0.6, 0.6);
            
            ctx.fillStyle = '#fff';
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 1;
            
            // Base
            ctx.beginPath();
            ctx.ellipse(0, 12, 10, 4, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Body
            ctx.beginPath();
            ctx.moveTo(-7, 10);
            ctx.quadraticCurveTo(-5, 0, -3, -4);
            ctx.quadraticCurveTo(0, -7, 3, -4);
            ctx.quadraticCurveTo(5, 0, 7, 10);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Head
            ctx.beginPath();
            ctx.arc(0, -9, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Evil eyes
            ctx.fillStyle = '#f00';
            ctx.beginPath();
            ctx.arc(-2, -10, 1.5, 0, Math.PI * 2);
            ctx.arc(2, -10, 1.5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        function drawKnight(x, y) {
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(0.6, 0.6);
            
            ctx.fillStyle = '#fff';
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 1;
            
            // Base
            ctx.beginPath();
            ctx.ellipse(0, 14, 12, 4, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Body
            ctx.beginPath();
            ctx.moveTo(-9, 11);
            ctx.quadraticCurveTo(-10, 0, -7, -8);
            ctx.lineTo(4, -13);
            ctx.quadraticCurveTo(10, -8, 9, 11);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Horse head
            ctx.beginPath();
            ctx.moveTo(-7, -8);
            ctx.lineTo(-13, -6);
            ctx.lineTo(-15, -12);
            ctx.lineTo(-10, -15);
            ctx.lineTo(-4, -13);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Ear
            ctx.beginPath();
            ctx.moveTo(-7, -15);
            ctx.lineTo(-5, -21);
            ctx.lineTo(-3, -15);
            ctx.closePath();
            ctx.fill();
            
            // Evil eye
            ctx.fillStyle = '#f00';
            ctx.beginPath();
            ctx.arc(-10, -11, 2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        function drawBubbleShooter(x, y) {
            ctx.save();
            ctx.translate(x, y);
            
            // Pulsing glow
            const pulse = Math.sin(Date.now() / 200) * 3;
            ctx.shadowColor = '#ff6600';
            ctx.shadowBlur = 10 + pulse;
            
            // Body - orange/red bubble creature
            ctx.fillStyle = '#ff6600';
            ctx.beginPath();
            ctx.arc(0, 0, 14, 0, Math.PI * 2);
            ctx.fill();
            
            // Inner highlight
            ctx.fillStyle = '#ff9944';
            ctx.beginPath();
            ctx.arc(-3, -3, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Angry eyes
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(-5, -2, 3, 0, Math.PI * 2);
            ctx.arc(5, -2, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Red pupils
            ctx.fillStyle = '#f00';
            ctx.beginPath();
            ctx.arc(-5, -2, 1.5, 0, Math.PI * 2);
            ctx.arc(5, -2, 1.5, 0, Math.PI * 2);
            ctx.fill();
            
            // Mouth
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 4, 5, 0.2, Math.PI - 0.2);
            ctx.stroke();
            
            ctx.restore();
        }
        
        function drawShields() {
            if (shields <= 0) return;
            
            ctx.save();
            ctx.translate(player.x, player.y);
            
            // Draw shield rings
            const time = Date.now() / 500;
            
            for (let i = 0; i < shields; i++) {
                const offset = (time + i * 2.1) % (Math.PI * 2);
                const alpha = 0.4 + 0.2 * Math.sin(time * 2 + i);
                
                ctx.strokeStyle = `rgba(0, 170, 255, ${alpha})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, 18 + i * 4, offset, offset + Math.PI * 1.3);
                ctx.stroke();
                
                // Shield sparkle
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                const sparkleX = Math.cos(offset) * (18 + i * 4);
                const sparkleY = Math.sin(offset) * (18 + i * 4);
                ctx.beginPath();
                ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        function drawBoss() {
            if (!boss) return;
            
            ctx.save();
            ctx.translate(boss.x, boss.y);
            
            const healthPercent = boss.health / boss.maxHealth;
            boss.animTimer = (boss.animTimer || 0) + 1;
            
            // Damage glow for all bosses
            if (healthPercent < 0.5) {
                ctx.shadowColor = '#f00';
                ctx.shadowBlur = 15 + Math.sin(Date.now() / 100) * 8;
            }
            
            // Draw based on boss type
            if (boss.type === 'mainboss') {
                drawMainBoss(boss.bossNum, healthPercent, boss.animTimer);
            } else {
                drawMiniBoss(healthPercent);
            }
            
            // Health bar
            ctx.shadowBlur = 0;
            const barWidth = boss.type === 'mainboss' ? 100 : 80;
            ctx.fillStyle = '#333';
            ctx.fillRect(-barWidth/2, 45, barWidth, 8);
            ctx.fillStyle = healthPercent > 0.3 ? '#f00' : '#ff0';
            ctx.fillRect(-barWidth/2, 45, barWidth * healthPercent, 8);
            ctx.strokeStyle = '#666';
            ctx.strokeRect(-barWidth/2, 45, barWidth, 8);
            
            // Boss name for main bosses
            if (boss.type === 'mainboss') {
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 10px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(MAIN_BOSS_NAMES[boss.bossNum - 1], 0, 62);
            }
            
            ctx.restore();
        }
        
        function drawMiniBoss(healthPercent) {
            const scale = 1.8;
            
            ctx.fillStyle = healthPercent < 0.3 ? '#ff6666' : '#fff';
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            
            // Crown
            ctx.fillStyle = '#ffd700';
            ctx.beginPath();
            ctx.moveTo(-18 * scale / 2, -22 * scale / 2);
            ctx.lineTo(-13 * scale / 2, -32 * scale / 2);
            ctx.lineTo(-8 * scale / 2, -25 * scale / 2);
            ctx.lineTo(0, -35 * scale / 2);
            ctx.lineTo(8 * scale / 2, -25 * scale / 2);
            ctx.lineTo(13 * scale / 2, -32 * scale / 2);
            ctx.lineTo(18 * scale / 2, -22 * scale / 2);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            ctx.fillStyle = healthPercent < 0.3 ? '#ff6666' : '#fff';
            
            // Base
            ctx.beginPath();
            ctx.ellipse(0, 12 * scale / 2, 15 * scale / 2, 5 * scale / 2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Body
            ctx.beginPath();
            ctx.moveTo(-12 * scale / 2, 10 * scale / 2);
            ctx.quadraticCurveTo(-14 * scale / 2, 0, -10 * scale / 2, -8 * scale / 2);
            ctx.lineTo(6 * scale / 2, -15 * scale / 2);
            ctx.quadraticCurveTo(14 * scale / 2, -8 * scale / 2, 12 * scale / 2, 10 * scale / 2);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Horse head
            ctx.beginPath();
            ctx.moveTo(-8 * scale / 2, -10 * scale / 2);
            ctx.lineTo(-18 * scale / 2, -6 * scale / 2);
            ctx.lineTo(-22 * scale / 2, -14 * scale / 2);
            ctx.lineTo(-14 * scale / 2, -18 * scale / 2);
            ctx.lineTo(-5 * scale / 2, -15 * scale / 2);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Evil eye
            ctx.fillStyle = '#f00';
            ctx.shadowColor = '#f00';
            ctx.shadowBlur = 12;
            ctx.beginPath();
            ctx.arc(-15 * scale / 2, -11 * scale / 2, 3, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function drawMainBoss(bossNum, healthPercent, animTimer) {
            switch(bossNum) {
                case 1: drawBoss1_StandingHorse(healthPercent, animTimer); break;
                case 2: drawBoss2_GallopingHorse(healthPercent, animTimer); break;
                case 3: drawBoss3_BabyHorse(healthPercent, animTimer); break;
                case 4: drawBoss4_BasketballHorse(healthPercent, animTimer); break;
            }
        }
        
        // Boss 1: Standing cute horse (top-left image)
        function drawBoss1_StandingHorse(hp, t) {
            const bob = Math.sin(t / 15) * 3;
            const color = hp < 0.3 ? '#d4856e' : '#c4956e';
            
            ctx.fillStyle = color;
            ctx.strokeStyle = '#5a3d2b';
            ctx.lineWidth = 2;
            
            // Body (oval)
            ctx.beginPath();
            ctx.ellipse(0, bob, 35, 22, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Legs (4 simple rectangles with animation)
            const legBob = Math.sin(t / 10) * 2;
            ctx.fillRect(-25, 15 + bob, 8, 20 + legBob);
            ctx.fillRect(-10, 15 + bob, 8, 22 - legBob);
            ctx.fillRect(5, 15 + bob, 8, 22 - legBob);
            ctx.fillRect(20, 15 + bob, 8, 20 + legBob);
            
            // Hooves
            ctx.fillStyle = '#4a3d2b';
            ctx.fillRect(-26, 33 + bob + legBob, 10, 5);
            ctx.fillRect(-11, 35 + bob - legBob, 10, 5);
            ctx.fillRect(4, 35 + bob - legBob, 10, 5);
            ctx.fillRect(19, 33 + bob + legBob, 10, 5);
            
            // Neck
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(-25, -5 + bob);
            ctx.quadraticCurveTo(-35, -25 + bob, -30, -35 + bob);
            ctx.lineTo(-20, -35 + bob);
            ctx.quadraticCurveTo(-15, -20 + bob, -20, -5 + bob);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Head
            ctx.beginPath();
            ctx.ellipse(-28, -40 + bob, 15, 12, -0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Snout
            ctx.fillStyle = '#e8c8a8';
            ctx.beginPath();
            ctx.ellipse(-38, -35 + bob, 8, 7, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Nostrils
            ctx.fillStyle = '#5a3d2b';
            ctx.beginPath();
            ctx.arc(-40, -33 + bob, 2, 0, Math.PI * 2);
            ctx.arc(-36, -33 + bob, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Eyes (cute, blinking)
            const blink = Math.sin(t / 30) > 0.95 ? 0.2 : 1;
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.ellipse(-25, -42 + bob, 4, 4 * blink, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-24, -43 + bob, 1.5, 0, Math.PI * 2);
            ctx.fill();
            
            // Ears
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.ellipse(-32, -52 + bob, 5, 8, -0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            ctx.beginPath();
            ctx.ellipse(-22, -52 + bob, 5, 8, 0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Inner ears (pink)
            ctx.fillStyle = '#e8a8a8';
            ctx.beginPath();
            ctx.ellipse(-32, -50 + bob, 3, 5, -0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(-22, -50 + bob, 3, 5, 0.3, 0, Math.PI * 2);
            ctx.fill();
            
            // Mane
            ctx.fillStyle = '#6a4d3b';
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.ellipse(-25 + i * 3, -30 + bob + Math.sin(t/8 + i) * 2, 4, 8, 0.3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Tail (wagging)
            const tailWag = Math.sin(t / 8) * 15;
            ctx.strokeStyle = '#6a4d3b';
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(35, 0 + bob);
            ctx.quadraticCurveTo(50 + tailWag, 10 + bob, 55 + tailWag, 25 + bob);
            ctx.stroke();
        }
        
        // Boss 2: Galloping/Running horse (top-right image)
        function drawBoss2_GallopingHorse(hp, t) {
            const color = hp < 0.3 ? '#d4856e' : '#c4956e';
            const runCycle = t / 5;
            
            ctx.fillStyle = color;
            ctx.strokeStyle = '#5a3d2b';
            ctx.lineWidth = 2;
            
            // Body (stretched for running)
            ctx.beginPath();
            ctx.ellipse(0, 0, 40, 18, 0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Running legs (animated)
            const frontLeg1 = Math.sin(runCycle) * 25;
            const frontLeg2 = Math.sin(runCycle + Math.PI) * 25;
            const backLeg1 = Math.sin(runCycle + Math.PI/2) * 25;
            const backLeg2 = Math.sin(runCycle + Math.PI * 1.5) * 25;
            
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';
            ctx.strokeStyle = color;
            
            // Front legs
            ctx.beginPath();
            ctx.moveTo(-20, 12);
            ctx.lineTo(-20 + frontLeg1/2, 30);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(-10, 12);
            ctx.lineTo(-10 + frontLeg2/2, 32);
            ctx.stroke();
            
            // Back legs
            ctx.beginPath();
            ctx.moveTo(20, 12);
            ctx.lineTo(20 + backLeg1/2, 30);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(30, 12);
            ctx.lineTo(30 + backLeg2/2, 32);
            ctx.stroke();
            
            // Hooves
            ctx.fillStyle = '#4a3d2b';
            ctx.beginPath();
            ctx.arc(-20 + frontLeg1/2, 32, 4, 0, Math.PI * 2);
            ctx.arc(-10 + frontLeg2/2, 34, 4, 0, Math.PI * 2);
            ctx.arc(20 + backLeg1/2, 32, 4, 0, Math.PI * 2);
            ctx.arc(30 + backLeg2/2, 34, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Neck (stretched forward)
            ctx.fillStyle = color;
            ctx.strokeStyle = '#5a3d2b';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-30, -5);
            ctx.quadraticCurveTo(-50, -20, -45, -30);
            ctx.lineTo(-35, -28);
            ctx.quadraticCurveTo(-35, -15, -25, -5);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Head
            ctx.beginPath();
            ctx.ellipse(-48, -32, 14, 10, -0.4, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Snout
            ctx.fillStyle = '#e8c8a8';
            ctx.beginPath();
            ctx.ellipse(-58, -28, 7, 6, -0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Nostrils (flaring)
            ctx.fillStyle = '#5a3d2b';
            const nostrilFlare = Math.sin(runCycle * 2) * 1 + 2;
            ctx.beginPath();
            ctx.arc(-60, -26, nostrilFlare, 0, Math.PI * 2);
            ctx.arc(-56, -26, nostrilFlare, 0, Math.PI * 2);
            ctx.fill();
            
            // Eyes (determined look)
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.ellipse(-45, -35, 4, 3, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-44, -36, 1.5, 0, Math.PI * 2);
            ctx.fill();
            
            // Ears (back, running pose)
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.ellipse(-42, -42, 4, 7, -0.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            ctx.beginPath();
            ctx.ellipse(-35, -40, 4, 7, 0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Mane (flowing back)
            ctx.fillStyle = '#6a4d3b';
            for (let i = 0; i < 7; i++) {
                const flow = Math.sin(runCycle + i * 0.5) * 5;
                ctx.beginPath();
                ctx.ellipse(-30 + i * 8 + flow, -15 + Math.sin(i) * 3, 5, 10, 0.5, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Tail (streaming back)
            ctx.strokeStyle = '#6a4d3b';
            ctx.lineWidth = 8;
            const tailStream = Math.sin(runCycle) * 10;
            ctx.beginPath();
            ctx.moveTo(40, 0);
            ctx.quadraticCurveTo(60, 5 + tailStream, 75, 0 + tailStream);
            ctx.stroke();
        }
        
        // Boss 3: Sitting baby horse (bottom-left image)
        function drawBoss3_BabyHorse(hp, t) {
            const color = hp < 0.3 ? '#a06048' : '#8B6048';
            const bob = Math.sin(t / 20) * 2;
            
            ctx.fillStyle = color;
            ctx.strokeStyle = '#4a3020';
            ctx.lineWidth = 2;
            
            // Body (sitting, round)
            ctx.beginPath();
            ctx.ellipse(0, 10 + bob, 30, 25, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Front legs (tucked)
            ctx.beginPath();
            ctx.ellipse(-15, 30 + bob, 12, 8, 0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            ctx.beginPath();
            ctx.ellipse(15, 30 + bob, 12, 8, -0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Hooves
            ctx.fillStyle = '#4a3020';
            ctx.beginPath();
            ctx.ellipse(-22, 32 + bob, 5, 4, 0, 0, Math.PI * 2);
            ctx.ellipse(22, 32 + bob, 5, 4, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Head (big for baby)
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.ellipse(0, -25 + bob, 25, 22, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // White marking on forehead
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.ellipse(0, -35 + bob, 6, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Snout
            ctx.fillStyle = '#d4a088';
            ctx.beginPath();
            ctx.ellipse(0, -12 + bob, 12, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Nostrils
            ctx.fillStyle = '#4a3020';
            ctx.beginPath();
            ctx.arc(-4, -10 + bob, 2, 0, Math.PI * 2);
            ctx.arc(4, -10 + bob, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // BIG cute eyes (anime style)
            const blink = Math.sin(t / 25) > 0.9 ? 0.1 : 1;
            // Eye whites
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.ellipse(-12, -28 + bob, 10, 10 * blink, 0, 0, Math.PI * 2);
            ctx.ellipse(12, -28 + bob, 10, 10 * blink, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#4a3020';
            ctx.stroke();
            
            // Pupils
            ctx.fillStyle = '#2a1810';
            ctx.beginPath();
            ctx.ellipse(-12, -26 + bob, 6, 7 * blink, 0, 0, Math.PI * 2);
            ctx.ellipse(12, -26 + bob, 6, 7 * blink, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Eye shine
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-14, -30 + bob, 3, 0, Math.PI * 2);
            ctx.arc(10, -30 + bob, 3, 0, Math.PI * 2);
            ctx.arc(-10, -24 + bob, 1.5, 0, Math.PI * 2);
            ctx.arc(14, -24 + bob, 1.5, 0, Math.PI * 2);
            ctx.fill();
            
            // Ears (big and floppy)
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.ellipse(-20, -45 + bob, 8, 12, -0.4, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            ctx.beginPath();
            ctx.ellipse(20, -45 + bob, 8, 12, 0.4, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Inner ears
            ctx.fillStyle = '#d4a088';
            ctx.beginPath();
            ctx.ellipse(-20, -43 + bob, 5, 8, -0.4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(20, -43 + bob, 5, 8, 0.4, 0, Math.PI * 2);
            ctx.fill();
            
            // Mane tuft
            ctx.fillStyle = '#5a3828';
            ctx.beginPath();
            ctx.ellipse(0, -48 + bob + Math.sin(t/10) * 2, 8, 10, 0, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Boss 4: Basketball horse head (bottom-right image) - FINAL BOSS
        function drawBoss4_BasketballHorse(hp, t) {
            const color = hp < 0.3 ? '#6a3828' : '#5a3020';
            const angry = Math.sin(t / 5) * 2;
            
            // Basketball first (behind head)
            ctx.fillStyle = '#e87830';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(25, 15, 25, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Basketball lines
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(25, 15, 25, 0, Math.PI * 2);
            ctx.moveTo(25, -10);
            ctx.lineTo(25, 40);
            ctx.moveTo(0, 15);
            ctx.lineTo(50, 15);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(25, 15, 18, -0.5, 0.5);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(25, 15, 18, Math.PI - 0.5, Math.PI + 0.5);
            ctx.stroke();
            
            // Horse hooves holding ball
            ctx.fillStyle = '#4a2818';
            ctx.beginPath();
            ctx.ellipse(5, 25, 10, 8, 0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(45, 25, 10, 8, -0.3, 0, Math.PI * 2);
            ctx.fill();
            
            // Big fierce horse head
            ctx.fillStyle = color;
            ctx.strokeStyle = '#2a1810';
            ctx.lineWidth = 3;
            
            // Head shape
            ctx.beginPath();
            ctx.ellipse(-25, -15 + angry, 35, 30, -0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Snout (longer, fiercer)
            ctx.beginPath();
            ctx.ellipse(-55, -5 + angry, 18, 15, -0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Nostrils (flaring angrily)
            ctx.fillStyle = '#1a0808';
            const flare = Math.abs(Math.sin(t / 4)) * 2 + 3;
            ctx.beginPath();
            ctx.ellipse(-62, -2 + angry, flare, flare * 0.7, 0, 0, Math.PI * 2);
            ctx.ellipse(-55, 0 + angry, flare, flare * 0.7, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Angry eyes
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.ellipse(-30, -25 + angry, 12, 8, 0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#2a1810';
            ctx.stroke();
            
            // Angry eyebrows
            ctx.strokeStyle = '#2a1810';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(-42, -38 + angry);
            ctx.lineTo(-25, -33 + angry);
            ctx.stroke();
            
            // Red pupil (evil)
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.ellipse(-28, -24 + angry, 6, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(-28, -24 + angry, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Mane (wild and fierce)
            ctx.fillStyle = '#3a2018';
            for (let i = 0; i < 8; i++) {
                const wave = Math.sin(t / 6 + i * 0.7) * 8;
                ctx.beginPath();
                ctx.ellipse(-15 + i * 5, -40 + wave + angry, 8, 15, 0.3 + i * 0.1, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Ears (alert, angry)
            ctx.fillStyle = color;
            ctx.strokeStyle = '#2a1810';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-35, -40 + angry);
            ctx.lineTo(-45, -60 + angry);
            ctx.lineTo(-30, -50 + angry);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(-15, -38 + angry);
            ctx.lineTo(-10, -58 + angry);
            ctx.lineTo(-5, -45 + angry);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }
        
        function drawBullets() {
            // Player bullets
            playerBullets.forEach(b => {
                ctx.fillStyle = b.color;
                ctx.shadowColor = b.color;
                ctx.shadowBlur = 8;
                
                if (b.type === 'homing') {
                    // Missile shape
                    ctx.save();
                    ctx.translate(b.x, b.y);
                    ctx.fillRect(-2, -6, 4, 12);
                    ctx.beginPath();
                    ctx.moveTo(0, -10);
                    ctx.lineTo(-3, -6);
                    ctx.lineTo(3, -6);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                } else {
                    ctx.beginPath();
                    ctx.ellipse(b.x, b.y, 3, 6, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            // Laser beam
            if (laserActive && currentWeapon === 'LASER') {
                const gradient = ctx.createLinearGradient(player.x - laserWidth, 0, player.x + laserWidth, 0);
                gradient.addColorStop(0, 'rgba(255, 0, 255, 0)');
                gradient.addColorStop(0.3, 'rgba(255, 0, 255, 0.8)');
                gradient.addColorStop(0.5, 'rgba(255, 255, 255, 1)');
                gradient.addColorStop(0.7, 'rgba(255, 0, 255, 0.8)');
                gradient.addColorStop(1, 'rgba(255, 0, 255, 0)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(player.x - laserWidth, 0, laserWidth * 2, player.y - 20);
                
                // Core
                ctx.fillStyle = '#fff';
                ctx.fillRect(player.x - 1, 0, 2, player.y - 20);
            }
            
            ctx.shadowBlur = 0;
            
            // Enemy bullets
            enemyBullets.forEach(b => {
                if (b.isBubble) {
                    // Big bubble bullet
                    const size = b.size || 10;
                    ctx.fillStyle = 'rgba(255, 100, 50, 0.7)';
                    ctx.strokeStyle = '#ff6600';
                    ctx.lineWidth = 2;
                    ctx.shadowColor = '#ff6600';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    
                    // Bubble shine
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.beginPath();
                    ctx.arc(b.x - size/3, b.y - size/3, size/4, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Normal bullet
                    ctx.fillStyle = '#ff4444';
                    ctx.shadowColor = '#ff4444';
                    ctx.shadowBlur = 6;
                    ctx.beginPath();
                    ctx.ellipse(b.x, b.y, 3, 5, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            ctx.shadowBlur = 0;
        }
        
        function drawPowerUps() {
            powerUps.forEach(p => {
                ctx.save();
                ctx.translate(p.x, p.y);
                
                const color = getPowerUpColor(p.type);
                const size = 28; // Bigger size
                
                // Pulsing glow effect
                const pulse = Math.sin(Date.now() / 150) * 5;
                ctx.shadowColor = color;
                ctx.shadowBlur = 20 + pulse;
                
                // Rounded box background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                
                // Draw rounded rect
                const r = 6;
                ctx.beginPath();
                ctx.moveTo(-size/2 + r, -size/2);
                ctx.lineTo(size/2 - r, -size/2);
                ctx.quadraticCurveTo(size/2, -size/2, size/2, -size/2 + r);
                ctx.lineTo(size/2, size/2 - r);
                ctx.quadraticCurveTo(size/2, size/2, size/2 - r, size/2);
                ctx.lineTo(-size/2 + r, size/2);
                ctx.quadraticCurveTo(-size/2, size/2, -size/2, size/2 - r);
                ctx.lineTo(-size/2, -size/2 + r);
                ctx.quadraticCurveTo(-size/2, -size/2, -size/2 + r, -size/2);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Icon - much bigger and bolder
                ctx.fillStyle = color;
                ctx.font = 'bold 16px Courier New';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(getPowerUpIcon(p.type), 0, -2);
                
                // Weapon name label below (smaller)
                ctx.shadowBlur = 0;
                ctx.font = '8px Courier New';
                ctx.fillStyle = color;
                ctx.fillText(getPowerUpName(p.type), 0, 10);
                
                ctx.restore();
            });
        }
        
        function getPowerUpColor(type) {
            switch(type) {
                case 'BEAM': return '#00ffff';
                case 'LASER': return '#ff00ff';
                case 'SPREAD': return '#ffff00';
                case 'HOMING': return '#00ff00';
                case 'LEVELUP': return '#ffffff';
                case 'SPECIAL': return '#ffd700';
                case 'SHIELD': return '#00aaff';
                case 'HEART': return '#ff6b9d';
                default: return '#fff';
            }
        }
        
        function getPowerUpIcon(type) {
            switch(type) {
                case 'BEAM': return 'â‰¡';
                case 'LASER': return 'â†¯';
                case 'SPREAD': return 'â‚';
                case 'HOMING': return 'â—';
                case 'LEVELUP': return 'â¬†';
                case 'SPECIAL': return 'â˜…';
                case 'SHIELD': return 'â—‡';
                case 'HEART': return 'â™¥';
                default: return '?';
            }
        }
        
        function getPowerUpName(type) {
            switch(type) {
                case 'BEAM': return 'BEAM';
                case 'LASER': return 'LASER';
                case 'SPREAD': return 'SPREAD';
                case 'HOMING': return 'HOME';
                case 'LEVELUP': return 'LV UP';
                case 'SPECIAL': return 'BOMB';
                case 'SHIELD': return 'SHIELD';
                case 'HEART': return 'LIFE';
                default: return '';
            }
        }
        
        function drawParticles() {
            particles.forEach(p => {
                if (p.type === 'flash') {
                    ctx.fillStyle = `rgba(255, 255, 255, ${p.alpha})`;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                } else {
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.life / 20;
                    ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
                    ctx.globalAlpha = 1;
                }
            });
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // UPDATE FUNCTIONS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function update(deltaTime) {
            if (!gameStarted || gameOver || victory) return;
            
            updateStars();
            updateNotifications();
            
            // Player movement
            if (keys.left && player.x > 25) {
                player.x -= player.speed;
            }
            if (keys.right && player.x < canvas.width - 25) {
                player.x += player.speed;
            }
            
            // Auto-fire
            autoFireTimer += deltaTime;
            const fireRate = WEAPONS[currentWeapon].fireRate;
            if (autoFireTimer >= fireRate) {
                autoFireTimer = 0;
                if (currentWeapon !== 'LASER') {
                    fireWeapon();
                }
            }
            
            // Laser is continuous
            if (currentWeapon === 'LASER') {
                const level = getWeaponLevel();
                laserActive = true;
                laserWidth = level * 3 + 4;
                
                // Laser damage scales with level: 0.02, 0.03, 0.05, 0.07, 0.1, 0.15, 0.2
                const laserDamage = [0.02, 0.03, 0.05, 0.07, 0.1, 0.15, 0.2][level - 1] || 0.02;
                const bossDamage = laserDamage * 0.5;
                
                // Check laser collision
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    if (Math.abs(enemy.x - player.x) < laserWidth + enemy.width/2) {
                        enemy.health -= laserDamage;
                        if (enemy.health <= 0) {
                            score += enemy.points;
                            spawnParticles(enemy.x, enemy.y, '#f0f');
                            if (enemy.hasPowerUp) spawnPowerUp(enemy.x, enemy.y);
                            enemies.splice(i, 1);
                            updateUI();
                        }
                    }
                }
                
                if (boss && Math.abs(boss.x - player.x) < laserWidth + boss.width/2) {
                    boss.health -= bossDamage;
                    if (boss.health <= 0) {
                        score += boss.points;
                        spawnParticles(boss.x, boss.y, '#ff0');
                        
                        if (boss.type === 'mainboss') {
                            gameSpeed += 0.1;
                            showNotification('SPEED UP! ' + Math.round(gameSpeed * 100) + '%', '#ff6600');
                        }
                        
                        boss = null;
                        bossActive = false;
                        
                        wave++;
                        if (wave > 8) {
                            showVictory();
                        } else {
                            if (wave >= 5) {
                                showNotification('BOSS ' + (wave - 5) + '/4 DEFEATED!', '#00ff00');
                            }
                            updateUI();
                            setTimeout(() => initWave(wave), 1500);
                        }
                    }
                    updateUI();
                }
            } else {
                laserActive = false;
            }
            
            // Special attack
            if (keys.special) {
                useSpecialAttack();
                keys.special = false;
            }
            
            // Update player bullets
            playerBullets = playerBullets.filter(b => {
                // Movement
                b.y -= b.speed;
                if (b.dx) b.x += b.dx;
                
                // Homing logic
                if (b.type === 'homing' && (enemies.length > 0 || boss)) {
                    let target = boss;
                    if (!target && enemies.length > 0) {
                        target = enemies.reduce((closest, e) => {
                            const dist = Math.hypot(e.x - b.x, e.y - b.y);
                            const closestDist = closest ? Math.hypot(closest.x - b.x, closest.y - b.y) : Infinity;
                            return dist < closestDist ? e : closest;
                        }, null);
                    }
                    
                    if (target) {
                        const angle = Math.atan2(target.y - b.y, target.x - b.x);
                        b.x += Math.cos(angle) * 1.5;
                        b.y += Math.sin(angle) * 1.5;
                    }
                }
                
                return b.y > -10 && b.x > -10 && b.x < canvas.width + 10;
            });
            
            // Update enemy bullets
            enemyBullets = enemyBullets.filter(b => {
                b.y += b.speed;
                if (b.dx) b.x += b.dx;
                return b.y < canvas.height + 10;
            });
            
            // Update power-ups
            powerUps = powerUps.filter(p => {
                p.y += p.speed;
                
                // Collect
                if (Math.abs(p.x - player.x) < 25 && Math.abs(p.y - player.y) < 25) {
                    collectPowerUp(p);
                    return false;
                }
                
                return p.y < canvas.height + 20;
            });
            
            // Update particles
            particles = particles.filter(p => {
                if (p.type === 'flash') {
                    p.alpha -= 0.05;
                    p.duration--;
                    return p.duration > 0;
                } else {
                    p.x += p.dx;
                    p.y += p.dy;
                    p.life--;
                    return p.life > 0;
                }
            });
            
            // Enemy movement
            let moveDown = false;
            let direction = 1;
            
            enemies.forEach(enemy => {
                if (enemy.x <= 25 || enemy.x >= canvas.width - 25) {
                    moveDown = true;
                    direction = enemy.x <= 25 ? 1 : -1;
                }
            });
            
            enemies.forEach(enemy => {
                if (moveDown) {
                    enemy.y += 6 * gameSpeed;
                    enemy.moveDir = direction;
                }
                enemy.x += (enemy.moveDir || 1) * (0.22 + wave * 0.06) * gameSpeed;
            });
            
            // Boss movement
            if (boss) {
                boss.x += boss.speed * boss.direction * gameSpeed;
                if (boss.x <= 60 || boss.x >= canvas.width - 60) {
                    boss.direction *= -1;
                }
                
                // Speed up when damaged
                const baseSpeed = boss.type === 'mainboss' ? 
                    [0.8, 1.0, 1.1, 1.3][boss.bossNum - 1] : 0.75;
                if (boss.health < boss.maxHealth * 0.5) boss.speed = baseSpeed * 1.4;
                if (boss.health < boss.maxHealth * 0.25) boss.speed = baseSpeed * 1.8;
            }
            
            // Enemy shooting - rate increases with gameSpeed
            if (enemies.length > 0 && Math.random() < (0.01 + wave * 0.0015) * gameSpeed) {
                const shooter = enemies[Math.floor(Math.random() * enemies.length)];
                
                if (shooter.type === BUBBLE_SHOOTER) {
                    // Bubble shooter fires big slow bubble
                    enemyBullets.push({
                        x: shooter.x,
                        y: shooter.y + 15,
                        speed: 1.0 * gameSpeed,
                        isBubble: true,
                        size: 12
                    });
                } else {
                    // Normal enemy bullet
                    enemyBullets.push({
                        x: shooter.x,
                        y: shooter.y + 15,
                        speed: (1.5 + wave * 0.15) * gameSpeed
                    });
                }
            }
            
            // Boss shooting - rate increases with gameSpeed
            if (boss && Math.random() < 0.02 * gameSpeed) {
                // Normal spread shot
                for (let i = -1; i <= 1; i++) {
                    enemyBullets.push({
                        x: boss.x + i * 25,
                        y: boss.y + 35,
                        speed: 1.9,
                        dx: i * 0.6
                    });
                }
            }
            
            // Boss bubble attack (less frequent but dangerous)
            if (boss && Math.random() < 0.008) {
                enemyBullets.push({
                    x: boss.x,
                    y: boss.y + 40,
                    speed: 1.5,
                    isBubble: true,
                    size: 18 // Big boss bubble!
                });
            }
            
            // Collision: Player bullets â†’ Enemies
            for (let bi = playerBullets.length - 1; bi >= 0; bi--) {
                const bullet = playerBullets[bi];
                
                for (let ei = enemies.length - 1; ei >= 0; ei--) {
                    const enemy = enemies[ei];
                    if (Math.abs(bullet.x - enemy.x) < enemy.width &&
                        Math.abs(bullet.y - enemy.y) < enemy.height) {
                        enemy.health -= bullet.damage;
                        playerBullets.splice(bi, 1);
                        
                        if (enemy.health <= 0) {
                            score += enemy.points;
                            spawnParticles(enemy.x, enemy.y, bullet.color);
                            if (enemy.hasPowerUp) spawnPowerUp(enemy.x, enemy.y);
                            enemies.splice(ei, 1);
                            updateUI();
                        }
                        break;
                    }
                }
                
                // Boss collision
                if (boss && bi < playerBullets.length) {
                    const b = playerBullets[bi];
                    if (b && Math.abs(b.x - boss.x) < boss.width/2 &&
                        Math.abs(b.y - boss.y) < boss.height/2) {
                        boss.health -= b.damage;
                        playerBullets.splice(bi, 1);
                        spawnParticles(b.x, b.y, b.color);
                        
                        if (boss.health <= 0) {
                            score += boss.points;
                            spawnParticles(boss.x, boss.y, '#ff0');
                            
                            // Check if this was a main boss - increase game speed
                            if (boss.type === 'mainboss') {
                                gameSpeed += 0.1; // 10% faster
                                showNotification('SPEED UP! ' + Math.round(gameSpeed * 100) + '%', '#ff6600');
                            }
                            
                            boss = null;
                            bossActive = false;
                            
                            // Progress to next wave
                            wave++;
                            if (wave > 8) {
                                showVictory();
                            } else {
                                // Show boss defeat message
                                if (wave >= 5) {
                                    showNotification('BOSS ' + (wave - 5) + '/4 DEFEATED!', '#00ff00');
                                }
                                updateUI();
                                setTimeout(() => initWave(wave), 1500);
                            }
                        }
                        updateUI();
                    }
                }
            }
            
            // Collision: Enemy bullets â†’ Player
            for (let bi = enemyBullets.length - 1; bi >= 0; bi--) {
                const bullet = enemyBullets[bi];
                const hitSize = bullet.isBubble ? (bullet.size || 10) + 6 : 10; // Even smaller hitbox
                
                if (Math.abs(bullet.x - player.x) < hitSize &&
                    Math.abs(bullet.y - player.y) < hitSize) {
                    enemyBullets.splice(bi, 1);
                    loseLife();
                }
            }
            
            // Check if enemies reached bottom
            enemies.forEach(enemy => {
                if (enemy.y > canvas.height - 60) {
                    loseLife();
                    enemy.y = 60;
                }
            });
            
            // Wave complete
            if (enemies.length === 0 && !bossActive) {
                wave++;
                if (wave > 8) {
                    // Beat all 4 main bosses!
                    showVictory();
                } else {
                    updateUI();
                    initWave(wave);
                }
            }
        }
        
        function draw() {
            // Clear
            ctx.fillStyle = '#050510';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Stars
            drawStars();
            
            if (!gameStarted) return;
            
            // Enemies
            enemies.forEach(enemy => {
                if (enemy.type === PAWN) drawPawn(enemy.x, enemy.y);
                else if (enemy.type === BUBBLE_SHOOTER) drawBubbleShooter(enemy.x, enemy.y);
                else drawKnight(enemy.x, enemy.y);
                
                // Power-up indicator
                if (enemy.hasPowerUp) {
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y - enemy.height, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            // Boss
            if (boss) drawBoss();
            
            // Player
            drawPlayer();
            
            // Shields around player
            drawShields();
            
            // Bullets
            drawBullets();
            
            // Power-ups
            drawPowerUps();
            
            // Particles
            drawParticles();
            
            // Notifications
            drawNotifications();
            
            // Boss wave indicator
            if (wave === 4 && bossActive) {
                ctx.fillStyle = '#e8707e';
                ctx.font = '12px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('âš” THE HORSE KING âš”', canvas.width / 2, 25);
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GAME LOOP
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            
            update(deltaTime || 16);
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GAME FLOW
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function loseLife() {
            // Use shield first if available
            if (shields > 0) {
                shields--;
                showNotification('SHIELD LOST!', '#00aaff');
                spawnParticles(player.x, player.y, '#00aaff');
                updateUI();
                return;
            }
            
            lives--;
            updateUI();
            spawnParticles(player.x, player.y, '#e8707e');
            
            if (lives <= 0) {
                showGameOver();
            } else {
                showNotification('OUCH! ' + lives + ' LEFT', '#ff4444');
            }
        }
        
        function updateUI() {
            document.getElementById('score').textContent = score;
            
            // Show wave or boss number
            if (wave <= 3) {
                document.getElementById('wave').textContent = wave;
            } else if (wave === 4) {
                document.getElementById('wave').textContent = 'MINI';
            } else {
                document.getElementById('wave').textContent = 'BOSS ' + (wave - 4);
            }
            
            // Show hearts for lives (max display 10)
            const maxDisplay = 10;
            const livesDisplay = document.getElementById('livesDisplay');
            let heartsHTML = '';
            for (let i = 0; i < Math.min(lives, maxDisplay); i++) {
                heartsHTML += 'â™¥';
            }
            if (lives > maxDisplay) {
                heartsHTML += '+' + (lives - maxDisplay);
            }
            livesDisplay.innerHTML = heartsHTML;
            
            document.getElementById('weaponDisplay').textContent = currentWeapon + ' LV.' + getWeaponLevel();
        }
        
        function showGameOver() {
            gameOver = true;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOverScreen').classList.remove('hidden');
        }
        
        function showVictory() {
            victory = true;
            document.getElementById('victoryScore').textContent = score;
            document.getElementById('victoryScreen').classList.remove('hidden');
        }
        
        function restartGame() {
            gameStarted = true;
            gameOver = false;
            victory = false;
            score = 0;
            lives = 5;
            wave = 1;
            gameSpeed = 1.0; // Reset game speed
            mainBossLevel = 0;
            currentWeapon = 'BEAM';
            weaponLevels = { BEAM: 1, LASER: 1, SPREAD: 1, HOMING: 1 };
            specialAttacks = 3;
            shields = 0;
            player.x = 200;
            playerBullets = [];
            enemyBullets = [];
            powerUps = [];
            particles = [];
            notifications = [];
            
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('victoryScreen').classList.add('hidden');
            document.getElementById('specialCount').textContent = 'Ã—3';
            document.getElementById('specialBtn').disabled = false;
            
            updateUI();
            updateWeaponButton();
            initWave(1);
        }
        
        function startGame() {
            if (gameStarted) return;
            document.getElementById('startScreen').classList.add('hidden');
            gameStarted = true;
            lives = 5;  // Start with 5 lives
            initWave(1);
            updateUI();
            updateWeaponButton();
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // INPUT HANDLERS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // Keyboard
        document.addEventListener('keydown', (e) => {
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
            if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
            if (e.code === 'Space') {
                e.preventDefault();
                if (!gameStarted) startGame();
                else keys.special = true;
            }
            // Weapon switching with 1-4 keys
            if (e.code === 'Digit1') { currentWeapon = 'BEAM'; updateUI(); showNotification('BEAM LV.' + weaponLevels.BEAM, '#00ffff'); }
            if (e.code === 'Digit2') { currentWeapon = 'LASER'; updateUI(); showNotification('LASER LV.' + weaponLevels.LASER, '#ff00ff'); }
            if (e.code === 'Digit3') { currentWeapon = 'SPREAD'; updateUI(); showNotification('SPREAD LV.' + weaponLevels.SPREAD, '#ffff00'); }
            if (e.code === 'Digit4') { currentWeapon = 'HOMING'; updateUI(); showNotification('HOMING LV.' + weaponLevels.HOMING, '#00ff00'); }
            // Q/E to cycle weapons
            if (e.code === 'KeyQ') switchWeapon(-1);
            if (e.code === 'KeyE') switchWeapon(1);
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
            if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
        });
        
        // Start screen tap
        document.getElementById('startScreen').addEventListener('click', startGame);
        document.getElementById('startScreen').addEventListener('touchstart', (e) => {
            e.preventDefault();
            startGame();
        });
        
        // Mobile buttons
        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');
        const specialBtn = document.getElementById('specialBtn');
        
        // Left button
        leftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); keys.left = true; leftBtn.classList.add('active'); });
        leftBtn.addEventListener('touchend', () => { keys.left = false; leftBtn.classList.remove('active'); });
        leftBtn.addEventListener('touchcancel', () => { keys.left = false; leftBtn.classList.remove('active'); });
        leftBtn.addEventListener('mousedown', () => { keys.left = true; });
        leftBtn.addEventListener('mouseup', () => { keys.left = false; });
        leftBtn.addEventListener('mouseleave', () => { keys.left = false; });
        
        // Right button
        rightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); keys.right = true; rightBtn.classList.add('active'); });
        rightBtn.addEventListener('touchend', () => { keys.right = false; rightBtn.classList.remove('active'); });
        rightBtn.addEventListener('touchcancel', () => { keys.right = false; rightBtn.classList.remove('active'); });
        rightBtn.addEventListener('mousedown', () => { keys.right = true; });
        rightBtn.addEventListener('mouseup', () => { keys.right = false; });
        rightBtn.addEventListener('mouseleave', () => { keys.right = false; });
        
        // Special button
        specialBtn.addEventListener('touchstart', (e) => { e.preventDefault(); keys.special = true; });
        specialBtn.addEventListener('click', () => { keys.special = true; });
        
        // Side weapon switch buttons
        const weaponBtnLeft = document.getElementById('weaponBtnLeft');
        const weaponBtnRight = document.getElementById('weaponBtnRight');
        
        weaponBtnLeft.addEventListener('touchstart', (e) => { e.preventDefault(); switchWeapon(-1); });
        weaponBtnLeft.addEventListener('click', () => { switchWeapon(-1); });
        
        weaponBtnRight.addEventListener('touchstart', (e) => { e.preventDefault(); switchWeapon(1); });
        weaponBtnRight.addEventListener('click', () => { switchWeapon(1); });
        
        // Prevent scrolling
        document.body.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
        
        // Start game loop
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
