<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>M.A.R.A. - DIVISION 4 ARCADE</title>
    <style>
        :root { --rabbit: #e8707e; --cyan: #00ffff; --gold: #ffd700; --bg-dark: #050510; }
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; -webkit-tap-highlight-color: transparent; }
        html, body { height: 100%; height: 100dvh; overflow: hidden; background: var(--bg-dark); }
        body { display: flex; flex-direction: column; align-items: center; justify-content: flex-start; font-family: 'Courier New', monospace; color: #fff; touch-action: none; padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left); padding-top: max(4px, env(safe-area-inset-top)); padding-bottom: max(4px, env(safe-area-inset-bottom)); }
        .game-container { position: relative; display: flex; flex-direction: column; align-items: center; width: 100%; max-width: 400px; height: 100%; max-height: 100dvh; }
        .game-header { display: flex; justify-content: space-between; align-items: center; width: 100%; padding: 8px 12px; font-size: 0.65rem; color: rgba(255, 140, 50, 0.8); text-transform: uppercase; letter-spacing: 0.12em; background: rgba(0, 5, 10, 0.95); border-bottom: 1px solid rgba(255, 120, 0, 0.25); flex-shrink: 0; }
        .power-bar-container { position: relative; width: 60px; height: 10px; background: rgba(255, 100, 0, 0.1); border: 1px solid rgba(255, 120, 0, 0.3); border-radius: 2px; overflow: hidden; }
        .power-bar { height: 100%; width: 14.28%; background: linear-gradient(90deg, rgba(0, 255, 220, 0.6), rgba(0, 255, 220, 0.9)); transition: width 0.3s ease; }
        .power-bar.maxed { background: linear-gradient(90deg, rgba(255, 150, 255, 0.8), rgba(255, 255, 255, 0.95)); animation: powerPulse 0.5s ease-in-out infinite alternate; }
        @keyframes powerPulse { from { opacity: 0.8; } to { opacity: 1; } }
        .power-label { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 0.4rem; color: rgba(255, 255, 255, 0.6); letter-spacing: 0.15em; pointer-events: none; }
        .rabbit-mode { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 0.35rem; color: rgba(255, 200, 255, 1); letter-spacing: 0.1em; white-space: nowrap; animation: rabbitBlink 0.4s ease-in-out infinite; }
        @keyframes rabbitBlink { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }
        .lives-display { color: rgba(255, 100, 100, 0.9); font-size: 0.7rem; letter-spacing: 2px; }
        .game-title { text-align: center; padding: 6px 0 4px; flex-shrink: 0; }
        .game-title h1 { font-size: 1rem; font-weight: 400; color: rgba(0, 255, 220, 0.9); letter-spacing: 0.4em; margin-bottom: 2px; }
        .game-title .subtitle { font-size: 0.45rem; color: rgba(255, 140, 50, 0.5); letter-spacing: 0.2em; }
        .canvas-wrapper { position: relative; width: 100%; max-width: 400px; flex: 1; min-height: 0; display: flex; align-items: center; justify-content: center; }
        #gameCanvas { display: block; max-width: 100%; max-height: 100%; border: 1px solid rgba(255, 120, 0, 0.3); background: var(--bg-dark); }
        .crt-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; background: repeating-linear-gradient(0deg, rgba(0,0,0,0.03) 0px, rgba(0,0,0,0.03) 1px, transparent 1px, transparent 2px); opacity: 0.5; }
        .weapon-hud { position: absolute; top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; gap: 3px; z-index: 15; pointer-events: auto; }
        .weapon-hud.left { left: 0; }
        .weapon-hud.right { right: 0; }
        .weapon-btn { padding: 10px 18px; min-width: 70px; background: rgba(255, 100, 0, 0.06); border: 1px solid rgba(255, 120, 0, 0.2); color: rgba(255, 140, 50, 0.4); font-family: 'Courier New', monospace; font-size: 0.6rem; letter-spacing: 0.2em; cursor: pointer; text-transform: uppercase; -webkit-tap-highlight-color: transparent; user-select: none; }
        .weapon-btn .weapon-label { display: block; }
        .weapon-btn .weapon-status { display: block; font-size: 0.45rem; margin-top: 3px; opacity: 0.5; }
        .weapon-hud.left .weapon-btn { border-left: none; border-radius: 0 3px 3px 0; text-align: left; }
        .weapon-hud.right .weapon-btn { border-right: none; border-radius: 3px 0 0 3px; text-align: right; }
        .weapon-btn:active { background: rgba(255, 140, 0, 0.12); }
        .weapon-btn.active { background: rgba(0, 255, 220, 0.08); border-color: rgba(0, 255, 220, 0.4); color: rgba(0, 255, 220, 0.95); }
        .weapon-btn.active .weapon-status { color: rgba(0, 255, 180, 0.9); opacity: 1; }
        @media (max-height: 600px) { .weapon-hud { gap: 2px; } .weapon-btn { padding: 6px 12px; min-width: 55px; font-size: 0.5rem; } .weapon-btn .weapon-status { font-size: 0.4rem; margin-top: 2px; } }
        .mobile-controls { display: flex; width: 100%; max-width: 400px; gap: 6px; padding: 6px; box-sizing: border-box; flex-shrink: 0; background: rgba(0, 5, 10, 0.8); border-top: 1px solid rgba(255, 120, 0, 0.2); }
        .control-btn { background: rgba(255, 100, 0, 0.06); border: 1px solid rgba(255, 120, 0, 0.3); color: rgba(255, 140, 50, 0.7); font-family: 'Courier New', monospace; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; -webkit-tap-highlight-color: transparent; user-select: none; }
        .control-btn:active, .control-btn.active { background: rgba(0, 255, 220, 0.15); border-color: rgba(0, 255, 220, 0.6); color: rgba(0, 255, 220, 0.95); transform: scale(0.97); }
        .move-btn { flex: 1; height: 65px; font-size: 1.5rem; }
        .bomb-btn { flex: 0.8; height: 65px; background: rgba(255, 60, 60, 0.08); border-color: rgba(255, 80, 80, 0.4); color: rgba(255, 100, 100, 0.8); flex-direction: column; gap: 2px; }
        .bomb-btn .btn-label { font-size: 0.55rem; }
        .bomb-btn .btn-icon { font-size: 0.7rem; opacity: 0.7; }
        .bomb-btn:disabled { opacity: 0.25; }
        .desktop-controls { margin-top: 10px; text-align: center; color: rgba(255, 140, 50, 0.4); font-size: 0.55rem; }
        @media (max-width: 500px) { .desktop-controls { display: none; } }
        @media (min-width: 501px) { .mobile-controls { display: none; } }
        .overlay-screen { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(180deg, rgba(5, 5, 20, 0.98), rgba(10, 5, 15, 0.98)); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 10; padding: 20px; }
        .hidden { display: none !important; }
        .overlay-screen h2 { font-size: 1.4rem; color: var(--rabbit); letter-spacing: 0.3em; margin-bottom: 8px; }
        .overlay-screen p { font-size: 0.65rem; color: var(--cyan); letter-spacing: 0.15em; margin-bottom: 8px; }
        .overlay-screen .story { font-size: 0.7rem; color: #aaa; text-align: center; max-width: 320px; line-height: 1.8; margin: 15px 0; }
        .overlay-screen .controls-info { background: rgba(255, 120, 0, 0.05); border: 1px solid rgba(255, 120, 0, 0.2); border-radius: 6px; padding: 12px; display: flex; flex-direction: column; gap: 10px; font-size: 0.6rem; color: rgba(255, 180, 100, 0.8); }
        .overlay-screen .blink { font-size: 0.75rem; color: #fff; letter-spacing: 0.3em; margin-top: 20px; animation: blink 1s infinite; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
        .logo { margin-bottom: 15px; }
        .logo img { width: 90px; height: 90px; border-radius: 12px; }
        .btn-restart { background: rgba(232, 112, 126, 0.15); border: 1px solid var(--rabbit); color: var(--rabbit); padding: 12px 30px; font-family: 'Courier New', monospace; font-size: 0.8rem; letter-spacing: 0.2em; cursor: pointer; margin-top: 20px; border-radius: 4px; }
        .settings-toggle { position: absolute; top: 8px; right: 8px; width: 32px; height: 32px; background: rgba(0, 0, 0, 0.5); border: 1px solid rgba(255, 120, 0, 0.3); border-radius: 4px; color: rgba(255, 140, 50, 0.7); font-size: 1rem; cursor: pointer; z-index: 20; display: flex; align-items: center; justify-content: center; }
        .settings-menu { position: absolute; top: 45px; right: 8px; background: rgba(10, 10, 20, 0.95); border: 1px solid rgba(255, 120, 0, 0.3); border-radius: 6px; padding: 12px; z-index: 20; display: none; flex-direction: column; gap: 10px; min-width: 140px; }
        .settings-menu.open { display: flex; }
        .setting-row { display: flex; justify-content: space-between; align-items: center; font-size: 0.65rem; color: rgba(255, 140, 50, 0.8); }
        .toggle-btn { width: 40px; height: 22px; background: rgba(100, 100, 100, 0.3); border: 1px solid rgba(255, 120, 0, 0.3); border-radius: 11px; cursor: pointer; position: relative; }
        .toggle-btn::after { content: ''; position: absolute; top: 2px; left: 2px; width: 16px; height: 16px; background: rgba(255, 140, 50, 0.6); border-radius: 50%; transition: left 0.2s; }
        .toggle-btn.active { background: rgba(0, 255, 220, 0.2); border-color: rgba(0, 255, 220, 0.5); }
        .toggle-btn.active::after { left: 20px; background: rgba(0, 255, 220, 0.9); }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <div class="power-bar-container">
                <div class="power-bar" id="powerBar"></div>
                <span class="power-label" id="powerLabel">PWR</span>
            </div>
            <div>WAVE <span id="waveNum">1</span></div>
            <div>SCORE <span id="score">0</span></div>
            <div class="lives-display" id="livesDisplay">♥♥♥♥♥</div>
        </div>
        <div class="game-title">
            <h1>M.A.R.A.</h1>
            <div class="subtitle">DIVISION 4 ARCADE</div>
        </div>
        <div class="canvas-wrapper">
            <canvas id="gameCanvas" width="400" height="500"></canvas>
            <div class="crt-overlay"></div>
            <div class="weapon-hud left" id="weaponHudLeft">
                <button class="weapon-btn active" data-weapon="RAILGUN"><span class="weapon-label">RAIL</span><span class="weapon-status">ACTIVE</span></button>
                <button class="weapon-btn" data-weapon="LASER"><span class="weapon-label">LASER</span><span class="weapon-status">READY</span></button>
            </div>
            <div class="weapon-hud right" id="weaponHudRight">
                <button class="weapon-btn" data-weapon="NOVA"><span class="weapon-label">NOVA</span><span class="weapon-status">READY</span></button>
                <button class="weapon-btn" data-weapon="SWARM"><span class="weapon-label">SWARM</span><span class="weapon-status">READY</span></button>
            </div>
            <button class="settings-toggle" id="settingsBtn">⚙</button>
            <div class="settings-menu" id="settingsMenu">
                <div class="setting-row"><span>Music</span><button class="toggle-btn active" id="musicToggle"></button></div>
                <div class="setting-row"><span>SFX</span><button class="toggle-btn active" id="soundToggle"></button></div>
            </div>
            <div class="overlay-screen" id="startScreen">
                <div class="logo"><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect fill='%23050510' width='100' height='100'/%3E%3Ctext x='50' y='60' text-anchor='middle' fill='%23e8707e' font-size='40' font-family='monospace'%3EM%3C/text%3E%3C/svg%3E" alt="M.A.R.A."></div>
                <h2>M.A.R.A.</h2>
                <p>MECHANICAL AUTONOMOUS RABBIT ARMAMENT</p>
                <div class="story">The herd has awakened.<br>Only you can stop them.</div>
                <div class="controls-info"><div>◄ ► MOVE</div><div>SIDE BUTTONS: WEAPONS</div><div>CENTER: BOMB</div></div>
                <div class="blink">TAP TO START</div>
            </div>
            <div class="overlay-screen hidden" id="gameOverScreen">
                <h2>GAME OVER</h2>
                <p>THE HERD PREVAILS</p>
                <div class="story">Final Score: <span id="finalScore">0</span></div>
                <button class="btn-restart" onclick="restartGame()">RETRY</button>
            </div>
            <div class="overlay-screen hidden" id="victoryScreen">
                <h2>VICTORY</h2>
                <p>THE HERD IS VANQUISHED</p>
                <div class="story">Score: <span id="victoryScore">0</span></div>
                <button class="btn-restart" id="continueBtn" onclick="continueToNewGamePlus()">NG+?</button>
                <button class="btn-restart" onclick="restartGame()">NEW GAME</button>
            </div>
        </div>
        <div class="mobile-controls">
            <button class="control-btn move-btn" id="leftBtn">◄</button>
            <button class="control-btn bomb-btn" id="specialBtn"><span class="btn-label">BOMB</span><span class="btn-icon" id="specialCount">×3</span></button>
            <button class="control-btn move-btn" id="rightBtn">►</button>
        </div>
        <div class="desktop-controls">A/D or ←/→ MOVE | 1-4 WEAPONS | Q/E CYCLE | SPACE BOMB</div>
    </div>

    <script>
        // ═══════════════════════════════════════
        // M.A.R.A. OPTIMIZED v3
        // - Boss sprites from GitHub
        // - Fixed freeze bugs (bossActive reset)
        // - Stronger weapons at max level
        // - 2x enemy HP
        // ═══════════════════════════════════════
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        
        let frameTime = 0, lastTime = 0;
        let gameStarted = false, gameOver = false, victory = false;
        let wave = 1, score = 0, lives = 5, gameSpeed = 1.0;
        let newGamePlusLevel = 0, waveTransitioning = false;
        let mainBossLevel = 0, bossActive = false;
        
        const player = { x: 200, y: 460, width: 24, height: 30 };
        let playerInvulnerable = false, invulnerableTimer = 0;
        let screenShake = 0, screenShakeIntensity = 0;
        
        // Audio
        let audioCtx = null, musicEnabled = true, soundEnabled = true;
        let musicOsc = null, musicGain = null;
        let laserOsc = null, laserGain = null, laserPlaying = false;
        
        // ═══════════════════════════════════════
        // BOSS SPRITE SYSTEM (from GitHub)
        // ═══════════════════════════════════════
        const BOSS_SPRITE_BASE = 'https://raw.githubusercontent.com/enjurogerjung-prog/therabbittest/main/';
        const bossSprites = {};
        let bossSpriteLoadCount = 0;
        [1,2,3,4].forEach(i => {
            bossSprites[i] = new Image();
            bossSprites[i].onload = () => { bossSpriteLoadCount++; };
            bossSprites[i].onerror = () => { console.log('Failed to load boss', i); };
            bossSprites[i].src = BOSS_SPRITE_BASE + 'boss' + i + '.jpg';
        });
        bossSprites[5] = new Image();
        bossSprites[5].onload = () => { bossSpriteLoadCount++; };
        bossSprites[5].onerror = () => { console.log('Failed to load boss 5'); };
        bossSprites[5].src = BOSS_SPRITE_BASE + 'TRUE%20LAST%20BOSS.png';
        
        const BOSS_SIZES = {
            1: { w: 108, h: 101 },
            2: { w: 116, h: 96 },
            3: { w: 91, h: 134 },
            4: { w: 286, h: 251 },
            5: { w: 225, h: 169 }
        };
        
        // Mini-boss sprite
        const miniBossSprite = new Image();
        miniBossSprite.src = 'https://raw.githubusercontent.com/enjurogerjung-prog/therabbittest/main/mecha_horse_miniboss.png';
        let miniBossSpriteLoaded = false;
        miniBossSprite.onload = () => { miniBossSpriteLoaded = true; };
        
        // ═══════════════════════════════════════
        // PARALLAX STARS
        // ═══════════════════════════════════════
        const farStars = [], midStars = [], nearStars = [];
        for (let i = 0; i < 40; i++) farStars.push({ x: Math.random() * 400, y: Math.random() * 500, size: 1, speed: 0.3, twinkle: Math.random() * Math.PI * 2 });
        for (let i = 0; i < 25; i++) midStars.push({ x: Math.random() * 400, y: Math.random() * 500, size: 1.5, speed: 0.8, color: ['#aaccff', '#ffccaa', '#ccffcc'][Math.floor(Math.random() * 3)] });
        for (let i = 0; i < 15; i++) nearStars.push({ x: Math.random() * 400, y: Math.random() * 500, size: 2, speed: 2, trail: 8 + Math.random() * 8 });
        
        function updateStars() {
            farStars.forEach(s => { s.y += s.speed * gameSpeed; if (s.y > 500) { s.y = 0; s.x = Math.random() * 400; } });
            midStars.forEach(s => { s.y += s.speed * gameSpeed; if (s.y > 500) { s.y = 0; s.x = Math.random() * 400; } });
            nearStars.forEach(s => { s.y += s.speed * gameSpeed; if (s.y > 500) { s.y = -s.trail; s.x = Math.random() * 400; } });
        }
        
        function drawStars() {
            const t = frameTime / 1000;
            farStars.forEach(s => { ctx.fillStyle = `rgba(255,255,255,${0.4 + Math.sin(t * 2 + s.twinkle) * 0.3})`; ctx.fillRect(s.x, s.y, s.size, s.size); });
            midStars.forEach(s => { ctx.fillStyle = s.color; ctx.globalAlpha = 0.7; ctx.fillRect(s.x, s.y, s.size, s.size); });
            ctx.globalAlpha = 1;
            nearStars.forEach(s => { ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(s.x, s.y - s.trail); ctx.lineTo(s.x, s.y); ctx.stroke(); ctx.fillStyle = '#fff'; ctx.fillRect(s.x - 1, s.y - 1, 2, 2); });
        }
        
        // ═══════════════════════════════════════
        // WEAPONS (STRONGER AT MAX LEVEL!)
        // ═══════════════════════════════════════
        const WEAPONS = {
            RAILGUN: { name: 'RAILGUN', color: '#00ffff', fireRate: 180 },
            LASER: { name: 'LASER', color: '#ff00ff', fireRate: 50 },
            NOVA: { name: 'NOVA', color: '#ffff00', fireRate: 280 },
            SWARM: { name: 'SWARM', color: '#00ff00', fireRate: 350 }
        };
        
        let currentWeapon = 'RAILGUN';
        let weaponLevel = 1;
        const MAX_WEAPON_LEVEL = 7;
        let specialAttacks = 3, specialReady = true, shields = 0;
        let laserActive = false;
        
        const WEAKNESSES = { 'pawn': 'NOVA', 'knight': 'RAILGUN', 'bubble': 'LASER', 'bouncer': 'SWARM', 'charger': 'NOVA', 'miniboss': 'LASER', 'miniboss2': 'LASER', 'mainboss': 'RAILGUN' };
        const BOSS_WEAKNESSES = { 1: 'RAILGUN', 2: 'NOVA', 3: 'SWARM', 4: 'LASER', 5: 'RAILGUN' };
        const WEAKNESS_MULTIPLIER = 2.5;
        
        function getWeakness(target) { if (target.type === 'mainboss' && target.bossNum) return BOSS_WEAKNESSES[target.bossNum] || 'RAILGUN'; return WEAKNESSES[target.type]; }
        function getDamageMultiplier(weapon, target) { return getWeakness(target) === weapon ? WEAKNESS_MULTIPLIER : 1; }
        
        function switchWeapon(dir) {
            const weapons = ['RAILGUN', 'LASER', 'NOVA', 'SWARM'];
            let idx = weapons.indexOf(currentWeapon);
            if (currentWeapon === 'LASER') { stopLaserSound(); laserActive = false; }
            idx = (idx + dir + 4) % 4;
            currentWeapon = weapons[idx];
            playSound('weaponSwitch');
            updateWeaponButtonDisplay();
            showNotification(WEAPONS[currentWeapon].name + ' LV.' + weaponLevel, WEAPONS[currentWeapon].color);
        }
        
        // ═══════════════════════════════════════
        // GAME OBJECTS
        // ═══════════════════════════════════════
        let playerBullets = [], enemyBullets = [], powerUps = [], particles = [], notifications = [];
        let enemies = [], boss = null;
        const PAWN = 'pawn', KNIGHT = 'knight', BUBBLE_SHOOTER = 'bubble', BOUNCER = 'bouncer', CHARGER = 'charger';
        const keys = { left: false, right: false, special: false };
        
        const TOTAL_WAVES = 24;
        const MAIN_BOSS_WAVES = [8, 12, 16, 20, 24];
        const MINI_BOSS_WAVES = [5, 11, 15, 19, 23];
        const DOUBLE_MINI_WAVES = [15, 19, 23];
        
        // ═══════════════════════════════════════
        // AUDIO
        // ═══════════════════════════════════════
        function initAudio() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
        function playSound(type) {
            if (!soundEnabled || !audioCtx) return;
            const osc = audioCtx.createOscillator(), gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;
            switch(type) {
                case 'shoot': osc.type = 'square'; osc.frequency.setValueAtTime(800, now); osc.frequency.exponentialRampToValueAtTime(200, now + 0.08); gain.gain.setValueAtTime(0.06, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08); osc.start(now); osc.stop(now + 0.08); break;
                case 'explosion': osc.type = 'sawtooth'; osc.frequency.setValueAtTime(150, now); osc.frequency.exponentialRampToValueAtTime(30, now + 0.25); gain.gain.setValueAtTime(0.12, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25); osc.start(now); osc.stop(now + 0.25); break;
                case 'playerHit': osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, now); osc.frequency.setValueAtTime(80, now + 0.1); gain.gain.setValueAtTime(0.15, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2); osc.start(now); osc.stop(now + 0.2); break;
                case 'powerup': osc.type = 'sine'; osc.frequency.setValueAtTime(400, now); osc.frequency.setValueAtTime(800, now + 0.1); osc.frequency.setValueAtTime(1200, now + 0.2); gain.gain.setValueAtTime(0.08, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25); osc.start(now); osc.stop(now + 0.25); break;
                case 'weaponSwitch': osc.type = 'sine'; osc.frequency.setValueAtTime(600, now); osc.frequency.setValueAtTime(900, now + 0.05); gain.gain.setValueAtTime(0.05, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08); osc.start(now); osc.stop(now + 0.08); break;
                case 'special': osc.type = 'square'; osc.frequency.setValueAtTime(200, now); osc.frequency.setValueAtTime(800, now + 0.3); gain.gain.setValueAtTime(0.12, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4); osc.start(now); osc.stop(now + 0.4); break;
            }
        }
        function startLaserSound() { if (!soundEnabled || !audioCtx || laserPlaying) return; laserOsc = audioCtx.createOscillator(); laserGain = audioCtx.createGain(); laserOsc.type = 'sine'; laserOsc.frequency.setValueAtTime(220, audioCtx.currentTime); laserGain.gain.setValueAtTime(0, audioCtx.currentTime); laserGain.gain.linearRampToValueAtTime(0.03, audioCtx.currentTime + 0.1); laserOsc.connect(laserGain); laserGain.connect(audioCtx.destination); laserOsc.start(); laserPlaying = true; }
        function stopLaserSound() { if (!laserPlaying || !laserOsc) return; laserGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1); setTimeout(() => { if (laserOsc) { laserOsc.stop(); laserOsc = null; } laserPlaying = false; }, 150); }
        function startMusic() { if (!musicEnabled || !audioCtx || musicOsc) return; musicOsc = audioCtx.createOscillator(); musicGain = audioCtx.createGain(); musicOsc.type = 'triangle'; musicOsc.frequency.setValueAtTime(110, audioCtx.currentTime); musicGain.gain.setValueAtTime(0.025, audioCtx.currentTime); musicOsc.connect(musicGain); musicGain.connect(audioCtx.destination); musicOsc.start(); }
        function stopMusic() { if (musicOsc) { musicOsc.stop(); musicOsc = null; } }
        
        // ═══════════════════════════════════════
        // PARTICLES & NOTIFICATIONS
        // ═══════════════════════════════════════
        function spawnParticles(x, y, color, count = 10) { for (let i = 0; i < count; i++) { const angle = Math.random() * Math.PI * 2, speed = 2 + Math.random() * 4; particles.push({ x, y, dx: Math.cos(angle) * speed, dy: Math.sin(angle) * speed, life: 25 + Math.random() * 15, color, size: 2 + Math.random() * 3 }); } }
        function spawnHitSparkles(x, y, color) { for (let i = 0; i < 5; i++) particles.push({ x: x + (Math.random() - 0.5) * 12, y: y + (Math.random() - 0.5) * 12, dx: (Math.random() - 0.5) * 8, dy: (Math.random() - 0.5) * 8, life: 12, color, size: 3 }); }
        function updateParticles() { for (let i = particles.length - 1; i >= 0; i--) { const p = particles[i]; if (p.type === 'flash') { p.duration--; if (p.duration <= 0) particles.splice(i, 1); } else { p.x += p.dx; p.y += p.dy; p.dy += 0.15; p.life--; if (p.life <= 0) particles.splice(i, 1); } } }
        function drawParticles() { particles.forEach(p => { if (p.type === 'flash') { ctx.fillStyle = `rgba(255,255,255,${p.alpha})`; ctx.fillRect(0, 0, 400, 500); } else { ctx.globalAlpha = Math.min(1, p.life / 15); ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill(); } }); ctx.globalAlpha = 1; }
        function showNotification(text, color = '#fff') { notifications.push({ text, color, y: 220, life: 70, alpha: 1 }); }
        function updateNotifications() { for (let i = notifications.length - 1; i >= 0; i--) { const n = notifications[i]; n.y -= 0.8; n.life--; n.alpha = Math.min(1, n.life / 25); if (n.life <= 0) notifications.splice(i, 1); } }
        function drawNotifications() { ctx.font = 'bold 14px Courier New'; ctx.textAlign = 'center'; notifications.forEach(n => { ctx.globalAlpha = n.alpha; ctx.fillStyle = n.color; ctx.globalAlpha = n.alpha * 0.3; ctx.fillText(n.text, 200, n.y - 1); ctx.fillText(n.text, 200, n.y + 1); ctx.fillText(n.text, 199, n.y); ctx.fillText(n.text, 201, n.y); ctx.globalAlpha = n.alpha; ctx.fillText(n.text, 200, n.y); }); ctx.globalAlpha = 1; }
        
        // ═══════════════════════════════════════
        // DRAWING FUNCTIONS
        // ═══════════════════════════════════════
        function drawPlayer() {
            if (playerInvulnerable && Math.floor(invulnerableTimer / 4) % 2 === 0) return;
            const t = frameTime / 100, flicker = Math.sin(t * 3) * 2, level = weaponLevel;
            ctx.save(); ctx.translate(player.x, player.y);
            if (level >= 3) { const auraSize = 25 + level * 5; ctx.globalAlpha = 0.1 + level * 0.02; ctx.fillStyle = WEAPONS[currentWeapon].color; ctx.beginPath(); ctx.arc(0, 0, auraSize + Math.sin(t) * 3, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1; }
            ctx.fillStyle = '#ff6600'; ctx.beginPath(); ctx.moveTo(-8, 12); ctx.lineTo(-10, 24 + flicker); ctx.lineTo(-6, 12); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(8, 12); ctx.lineTo(10, 24 + flicker); ctx.lineTo(6, 12); ctx.closePath(); ctx.fill();
            ctx.fillStyle = '#ffff00'; ctx.beginPath(); ctx.moveTo(-8, 12); ctx.lineTo(-9, 18 + flicker * 0.5); ctx.lineTo(-7, 12); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(8, 12); ctx.lineTo(9, 18 + flicker * 0.5); ctx.lineTo(7, 12); ctx.closePath(); ctx.fill();
            ctx.fillStyle = '#e8e8f0'; ctx.strokeStyle = level >= 4 ? WEAPONS[currentWeapon].color : '#888'; ctx.lineWidth = level >= 4 ? 2 : 1;
            ctx.beginPath(); ctx.moveTo(0, -12); ctx.lineTo(10, 0); ctx.lineTo(12, 10); ctx.lineTo(6, 14); ctx.lineTo(-6, 14); ctx.lineTo(-12, 10); ctx.lineTo(-10, 0); ctx.closePath(); ctx.fill(); ctx.stroke();
            ctx.fillStyle = '#c0c0c8'; ctx.beginPath(); ctx.moveTo(-10, 0); ctx.lineTo(-14, 5); ctx.lineTo(-12, 12); ctx.lineTo(-10, 10); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(14, 5); ctx.lineTo(12, 12); ctx.lineTo(10, 10); ctx.closePath(); ctx.fill();
            ctx.fillStyle = '#f0f0f5'; ctx.beginPath(); ctx.moveTo(-5, -10); ctx.quadraticCurveTo(-8, -25, -4, -28); ctx.quadraticCurveTo(-1, -25, -3, -10); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(5, -10); ctx.quadraticCurveTo(8, -25, 4, -28); ctx.quadraticCurveTo(1, -25, 3, -10); ctx.closePath(); ctx.fill();
            ctx.fillStyle = '#ffaaaa'; ctx.beginPath(); ctx.moveTo(-4, -12); ctx.quadraticCurveTo(-6, -22, -4, -24); ctx.quadraticCurveTo(-2, -22, -3, -12); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(4, -12); ctx.quadraticCurveTo(6, -22, 4, -24); ctx.quadraticCurveTo(2, -22, 3, -12); ctx.closePath(); ctx.fill();
            ctx.fillStyle = WEAPONS[currentWeapon].color; ctx.beginPath(); ctx.ellipse(0, -4, 6, 4, 0, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.ellipse(-2, -5, 2, 1.5, -0.3, 0, Math.PI * 2); ctx.fill();
            if (level >= 5) { ctx.fillStyle = '#ffd700'; ctx.font = 'bold 12px Arial'; ctx.textAlign = 'center'; ctx.fillText('★', 0, -33); }
            ctx.restore();
            if (level >= 5) { drawWingman(player.x - 35, player.y + 15, t, -1); drawWingman(player.x + 35, player.y + 15, t, 1); }
        }
        
        function drawWingman(x, y, t, side) {
            ctx.save(); ctx.translate(x, y); ctx.scale(0.55, 0.55);
            const flicker = Math.sin(t * 3 + side) * 2;
            ctx.fillStyle = '#ff6600'; ctx.beginPath(); ctx.moveTo(-5, 8); ctx.lineTo(-7, 16 + flicker); ctx.lineTo(-3, 8); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(5, 8); ctx.lineTo(7, 16 + flicker); ctx.lineTo(3, 8); ctx.closePath(); ctx.fill();
            ctx.fillStyle = '#d0d0d8'; ctx.strokeStyle = WEAPONS[currentWeapon].color; ctx.lineWidth = 1.5; ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(8, 2); ctx.lineTo(10, 10); ctx.lineTo(-10, 10); ctx.lineTo(-8, 2); ctx.closePath(); ctx.fill(); ctx.stroke();
            ctx.fillStyle = WEAPONS[currentWeapon].color; ctx.beginPath(); ctx.ellipse(0, -2, 4, 3, 0, 0, Math.PI * 2); ctx.fill();
            ctx.restore();
        }
        
        function drawShields() { if (shields <= 0) return; const t = frameTime / 400; for (let i = 0; i < shields; i++) { ctx.globalAlpha = 0.3 + Math.sin(t + i) * 0.15; ctx.strokeStyle = '#00aaff'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(player.x, player.y, 28 + i * 10, 0, Math.PI * 2); ctx.stroke(); } ctx.globalAlpha = 1; }
        
        function drawPawn(x, y) { ctx.save(); ctx.translate(x, y); const t = frameTime / 100, flicker = Math.sin(t * 4) * 2; ctx.fillStyle = '#ff6600'; ctx.beginPath(); ctx.moveTo(-4, 10); ctx.lineTo(-5, 16 + flicker); ctx.lineTo(-3, 10); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(4, 10); ctx.lineTo(5, 16 + flicker); ctx.lineTo(3, 10); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#909098'; ctx.beginPath(); ctx.moveTo(-8, 8); ctx.lineTo(-6, 12); ctx.lineTo(6, 12); ctx.lineTo(8, 8); ctx.lineTo(6, 4); ctx.lineTo(-6, 4); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(-7, 5); ctx.quadraticCurveTo(-8, 0, -6, -5); ctx.quadraticCurveTo(0, -12, 6, -5); ctx.quadraticCurveTo(8, 0, 7, 5); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#707078'; ctx.beginPath(); ctx.arc(0, -8, 4, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#ff3300'; ctx.beginPath(); ctx.ellipse(-3, -2, 2.5, 2, -0.2, 0, Math.PI * 2); ctx.ellipse(3, -2, 2.5, 2, 0.2, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#ffaa00'; ctx.beginPath(); ctx.arc(-3, -2, 1, 0, Math.PI * 2); ctx.arc(3, -2, 1, 0, Math.PI * 2); ctx.fill(); ctx.restore(); }
        function drawKnight(x, y) { ctx.save(); ctx.translate(x, y); const t = frameTime / 100, flicker = Math.sin(t * 3) * 2; ctx.fillStyle = '#ff6600'; ctx.beginPath(); ctx.moveTo(-3, 12); ctx.lineTo(-5, 20 + flicker); ctx.lineTo(5, 20 + flicker); ctx.lineTo(3, 12); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#303038'; ctx.fillRect(-12, 8, 6, 6); ctx.fillRect(6, 8, 6, 6); ctx.fillStyle = '#505060'; ctx.fillRect(-10, -4, 20, 14); ctx.fillRect(-10, -10, 5, 6); ctx.fillRect(-2, -10, 5, 6); ctx.fillRect(5, -10, 5, 6); ctx.fillStyle = '#ffcc00'; ctx.fillRect(-9, 4, 3, 2); ctx.fillRect(6, 4, 3, 2); ctx.fillStyle = '#ff3300'; ctx.beginPath(); ctx.moveTo(-6, -2); ctx.lineTo(-2, 0); ctx.lineTo(-6, 2); ctx.closePath(); ctx.moveTo(6, -2); ctx.lineTo(2, 0); ctx.lineTo(6, 2); ctx.closePath(); ctx.fill(); ctx.restore(); }
        function drawBubbleShooter(x, y) { ctx.save(); ctx.translate(x, y); const t = frameTime / 100, flicker = Math.sin(t * 3.5) * 2; ctx.strokeStyle = 'rgba(204, 34, 85, 0.3)'; ctx.lineWidth = 1; for (let i = 0; i < 3; i++) { const ringY = ((t * 8 + i * 10) % 30) - 15; ctx.globalAlpha = (1 - Math.abs(ringY) / 15) * 0.4; ctx.beginPath(); ctx.ellipse(0, ringY, 14 - Math.abs(ringY) * 0.3, 4, 0, 0, Math.PI * 2); ctx.stroke(); } ctx.globalAlpha = 1; ctx.fillStyle = '#ff6600'; ctx.beginPath(); ctx.moveTo(-3, 12); ctx.lineTo(0, 22 + flicker); ctx.lineTo(3, 12); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#c0c0c8'; ctx.beginPath(); ctx.moveTo(-8, 8); ctx.lineTo(-6, 14); ctx.lineTo(6, 14); ctx.lineTo(8, 8); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(-8, 8); ctx.quadraticCurveTo(-10, 0, -6, -8); ctx.quadraticCurveTo(0, -16, 6, -8); ctx.quadraticCurveTo(10, 0, 8, 8); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#cc2255'; ctx.beginPath(); ctx.arc(0, -4, 5, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#ff66aa'; ctx.beginPath(); ctx.arc(-1, -5, 2, 0, Math.PI * 2); ctx.fill(); ctx.restore(); }
        function drawBouncer(x, y, enemy) { ctx.save(); ctx.translate(x, y); const t = frameTime / 200, pulse = Math.sin(t * 4) * 2; ctx.globalAlpha = 0.2; ctx.fillStyle = '#8844ff'; ctx.beginPath(); ctx.arc(0, 0, 18 + pulse, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1; ctx.fillStyle = '#8844ff'; ctx.beginPath(); ctx.arc(0, 0, 14, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#aa66ff'; ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#ffff00'; ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI * 2); ctx.fill(); ctx.restore(); }
        function drawCharger(x, y, enemy) { ctx.save(); ctx.translate(x, y); const charging = enemy && enemy.charging; if (charging) { ctx.globalAlpha = 0.3; ctx.fillStyle = '#ff4400'; ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(18, 15); ctx.lineTo(-18, 15); ctx.closePath(); ctx.fill(); ctx.globalAlpha = 1; } ctx.fillStyle = charging ? '#ff4400' : '#ff6600'; ctx.beginPath(); ctx.moveTo(0, -15); ctx.lineTo(12, 10); ctx.lineTo(-12, 10); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#ffaa00'; ctx.beginPath(); ctx.arc(0, -8, 4, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = charging ? '#fff' : '#ffff00'; ctx.beginPath(); ctx.arc(-5, 0, 3, 0, Math.PI * 2); ctx.arc(5, 0, 3, 0, Math.PI * 2); ctx.fill(); ctx.restore(); }
        
        function drawMiniBoss(enemy) {
            ctx.save();
            ctx.translate(enemy.x, enemy.y);
            const t = frameTime / 100;
            const bob = Math.sin(t / 10) * 3;
            const isSecond = enemy.type === 'miniboss2';
            
            ctx.translate(0, bob);
            
            // Draw the mecha horse sprite
            if (miniBossSpriteLoaded) {
                const scale = 0.09; // Scale down the large image
                const w = 977 * scale;
                const h = 942 * scale;
                
                ctx.save();
                if (isSecond) ctx.scale(-1, 1); // Mirror second boss
                
                // Tint effect when damaged
                if (enemy.health < enemy.maxHealth * 0.3) {
                    ctx.globalAlpha = 0.7 + Math.sin(t) * 0.3;
                }
                
                ctx.drawImage(miniBossSprite, -w/2, -h/2, w, h);
                ctx.restore();
            } else {
                // Fallback: simple shape
                ctx.fillStyle = isSecond ? '#cc6644' : '#e8707e';
                ctx.beginPath();
                ctx.ellipse(0, 0, 35, 40, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('BOSS', 0, 5);
            }
            
            // HP bar
            if (enemy.health > 0 && enemy.maxHealth) {
                const barWidth = 60;
                ctx.fillStyle = '#333';
                ctx.fillRect(-barWidth/2, 50, barWidth, 6);
                ctx.fillStyle = enemy.health > enemy.maxHealth * 0.3 ? '#00ff00' : '#ff0000';
                ctx.fillRect(-barWidth/2, 50, barWidth * (enemy.health / enemy.maxHealth), 6);
            }
            ctx.restore();
        }
        
        function drawBoss() {
            if (!boss) return;
            ctx.save(); ctx.translate(boss.x, boss.y);
            const t = frameTime / 100, bossNum = boss.bossNum || 1, healthPercent = boss.health / boss.maxHealth;
            boss.animTimer = (boss.animTimer || 0) + 1;
            const size = BOSS_SIZES[bossNum] || BOSS_SIZES[1];
            const wiggle = Math.sin(boss.animTimer / 15) * 3, bounce = Math.sin(boss.animTimer / 10) * 2;
            
            // Damage flash
            if (healthPercent < 0.3 && Math.sin(boss.animTimer / 2) > 0) ctx.globalAlpha = 0.7;
            
            ctx.save();
            ctx.rotate(wiggle * 0.02);
            ctx.translate(0, bounce);
            
            // Draw sprite if loaded
            if (bossSprites[bossNum] && bossSprites[bossNum].complete && bossSprites[bossNum].naturalWidth > 0) {
                ctx.drawImage(bossSprites[bossNum], -size.w/2, -size.h/2, size.w, size.h);
            } else {
                // Fallback colored rectangle
                const colors = ['#d4a574', '#c4956a', '#8B6914', '#ff6600', '#aa00ff'];
                ctx.fillStyle = colors[(bossNum - 1) % 5];
                ctx.fillRect(-size.w/2, -size.h/2, size.w, size.h);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('BOSS ' + bossNum, 0, 5);
            }
            ctx.restore();
            ctx.globalAlpha = 1;
            
            // HP bar
            if (boss.health > 0 && boss.maxHealth) {
                const barWidth = Math.max(100, size.w * 0.8), barY = size.h/2 + 10;
                ctx.fillStyle = '#333'; ctx.fillRect(-barWidth/2, barY, barWidth, 8);
                ctx.fillStyle = healthPercent > 0.3 ? '#00ff00' : '#ff0000'; ctx.fillRect(-barWidth/2, barY, barWidth * healthPercent, 8);
            }
            ctx.restore();
        }
        
        function drawBullets() {
            playerBullets.forEach(b => {
                ctx.fillStyle = b.color || '#00ffff';
                if (b.type === 'volt') { ctx.globalAlpha = 0.3; ctx.fillRect(b.x - 4, b.y - 10, 8, 16); ctx.globalAlpha = 1; ctx.fillRect(b.x - 2, b.y - 8, 4, 14); }
                else if (b.type === 'seeker') { if (b.trail) { ctx.strokeStyle = b.color; ctx.globalAlpha = 0.3; ctx.lineWidth = 2; ctx.beginPath(); b.trail.forEach((p, i) => { if (i === 0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y); }); ctx.stroke(); ctx.globalAlpha = 1; } ctx.beginPath(); ctx.arc(b.x, b.y, 5, 0, Math.PI * 2); ctx.fill(); }
                else if (b.type === 'spread') { ctx.globalAlpha = 0.3; ctx.beginPath(); ctx.arc(b.x, b.y, 6, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1; ctx.beginPath(); ctx.arc(b.x, b.y, 4, 0, Math.PI * 2); ctx.fill(); }
                else { ctx.fillRect(b.x - 2, b.y - 6, 4, 12); }
            });
            
            enemyBullets.forEach(b => {
                if (b.isBubble) { ctx.fillStyle = 'rgba(200, 40, 80, 0.6)'; ctx.strokeStyle = '#cc2255'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(b.x, b.y, b.size || 10, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'; ctx.beginPath(); ctx.arc(b.x - 3, b.y - 3, 3, 0, Math.PI * 2); ctx.fill(); }
                else if (b.isOrangeBall) { ctx.fillStyle = '#ffaa00'; ctx.beginPath(); ctx.arc(b.x, b.y, (b.size || 14) + 4, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#ff8800'; ctx.beginPath(); ctx.arc(b.x, b.y, b.size || 14, 0, Math.PI * 2); ctx.fill(); }
                else if (b.isMissile) { ctx.fillStyle = '#ff6600'; ctx.beginPath(); ctx.moveTo(b.x - 3, b.y + 8); ctx.lineTo(b.x, b.y + 16 + Math.random() * 4); ctx.lineTo(b.x + 3, b.y + 8); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#aa0000'; ctx.beginPath(); ctx.moveTo(b.x, b.y - 8); ctx.lineTo(b.x + 5, b.y + 8); ctx.lineTo(b.x - 5, b.y + 8); ctx.closePath(); ctx.fill(); }
                else { ctx.fillStyle = '#ff3300'; ctx.beginPath(); ctx.arc(b.x, b.y, 4, 0, Math.PI * 2); ctx.fill(); }
            });
            
            // LASER BEAM (balanced width)
            if (laserActive && currentWeapon === 'LASER') {
                const level = weaponLevel;
                const baseWidth = 6 + level * 3; // Reasonable: 9 at L1, 27 at L7
                const t = frameTime / 50;
                
                ctx.globalAlpha = 0.15; ctx.fillStyle = '#ff00ff'; ctx.fillRect(player.x - baseWidth * 1.5, 0, baseWidth * 3, player.y - 10);
                ctx.globalAlpha = 0.35; ctx.fillStyle = '#ff88ff'; ctx.fillRect(player.x - baseWidth, 0, baseWidth * 2, player.y - 10);
                ctx.globalAlpha = 0.6; ctx.fillStyle = '#ffccff'; ctx.fillRect(player.x - baseWidth * 0.5, 0, baseWidth, player.y - 10);
                ctx.globalAlpha = 1; ctx.fillStyle = '#fff'; ctx.fillRect(player.x - 2, 0, 4, player.y - 10);
                
                for (let i = 0; i < 3; i++) { const pulseY = ((t * 10 + i * 150) % (player.y - 10)); ctx.globalAlpha = 0.5; ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.ellipse(player.x, player.y - 10 - pulseY, baseWidth * 0.8, 4, 0, 0, Math.PI * 2); ctx.fill(); }
                
                // Wingman lasers at level 5+
                if (level >= 5) {
                    const wingW = baseWidth * 0.4;
                    [-35, 35].forEach(offset => { ctx.globalAlpha = 0.25; ctx.fillStyle = '#ff00ff'; ctx.fillRect(player.x + offset - wingW, 0, wingW * 2, player.y + 5); ctx.globalAlpha = 0.5; ctx.fillStyle = '#ffccff'; ctx.fillRect(player.x + offset - wingW/2, 0, wingW, player.y + 5); });
                }
                ctx.globalAlpha = 1;
            }
        }
        
        function drawPowerUps() {
            powerUps.forEach(p => {
                ctx.save(); ctx.translate(p.x, p.y);
                const t = frameTime / 200, bob = Math.sin(t + p.x) * 3; ctx.translate(0, bob);
                if (p.type === 'UPGRADE') { ctx.fillStyle = 'rgba(0, 255, 255, 0.3)'; ctx.fillRect(-10, -10, 20, 20); ctx.fillStyle = '#00ffff'; ctx.fillRect(-8, -8, 16, 16); ctx.fillStyle = '#fff'; ctx.fillRect(-2, -6, 4, 12); ctx.fillRect(-6, -2, 12, 4); }
                else if (p.type === 'HEART') { ctx.fillStyle = '#ff4444'; ctx.beginPath(); ctx.arc(-4, -2, 6, 0, Math.PI * 2); ctx.arc(4, -2, 6, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.moveTo(-10, 0); ctx.lineTo(0, 12); ctx.lineTo(10, 0); ctx.closePath(); ctx.fill(); }
                else if (p.type === 'BOMB') { ctx.fillStyle = 'rgba(255, 170, 0, 0.3)'; ctx.beginPath(); ctx.arc(0, 0, 14, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#ffaa00'; ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#fff'; ctx.font = 'bold 12px Courier New'; ctx.textAlign = 'center'; ctx.fillText('B', 0, 5); }
                else if (p.type === 'SHIELD') { ctx.strokeStyle = '#00aaff'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI * 2); ctx.stroke(); ctx.strokeStyle = 'rgba(0, 170, 255, 0.3)'; ctx.lineWidth = 6; ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI * 2); ctx.stroke(); }
                ctx.restore();
            });
        }
        
        // ═══════════════════════════════════════
        // WEAPON FIRING (STRONGER AT MAX LEVEL!)
        // ═══════════════════════════════════════
        let lastFireTime = 0;
        
        function fireWeapon() {
            const weapon = WEAPONS[currentWeapon];
            if (frameTime - lastFireTime < weapon.fireRate) return;
            lastFireTime = frameTime;
            const level = weaponLevel;
            
            switch(currentWeapon) {
                case 'RAILGUN':
                    // Damage scales: 5, 6.5, 8, 9.5, 11, 12.5, 14
                    const dmg = 3.5 + level * 1.5;
                    playerBullets.push({ x: player.x, y: player.y - 20, dx: 0, dy: -1, speed: 16 + level * 0.3, damage: dmg, type: 'volt', color: '#00ffff' });
                    // Side shots at level 2+
                    if (level >= 2) {
                        const sideSpread = 0.06 + (level - 2) * 0.01;
                        playerBullets.push({ x: player.x - 12, y: player.y - 12, dx: -sideSpread, dy: -1, speed: 15, damage: dmg * 0.6, type: 'volt', color: '#00dddd' });
                        playerBullets.push({ x: player.x + 12, y: player.y - 12, dx: sideSpread, dy: -1, speed: 15, damage: dmg * 0.6, type: 'volt', color: '#00dddd' });
                    }
                    // Extra side shots at level 4+
                    if (level >= 4) {
                        playerBullets.push({ x: player.x - 20, y: player.y - 5, dx: -0.12, dy: -1, speed: 14, damage: dmg * 0.5, type: 'volt', color: '#00cccc' });
                        playerBullets.push({ x: player.x + 20, y: player.y - 5, dx: 0.12, dy: -1, speed: 14, damage: dmg * 0.5, type: 'volt', color: '#00cccc' });
                    }
                    // Wingman shots at level 5+
                    if (level >= 5) {
                        playerBullets.push({ x: player.x - 35, y: player.y + 5, dx: 0, dy: -1, speed: 14, damage: dmg * 0.4, type: 'volt', color: '#00aaaa' });
                        playerBullets.push({ x: player.x + 35, y: player.y + 5, dx: 0, dy: -1, speed: 14, damage: dmg * 0.4, type: 'volt', color: '#00aaaa' });
                    }
                    playSound('shoot'); break;
                    
                case 'NOVA':
                    // Spread count: 3, 4, 4, 5, 5, 6, 7
                    const spreadCount = 3 + Math.floor(level / 2);
                    const spreadAngle = 0.15 + level * 0.02;
                    const novaDmg = 2 + level * 0.5;
                    for (let i = 0; i < spreadCount; i++) {
                        const angle = -Math.PI/2 + (i - (spreadCount-1)/2) * spreadAngle;
                        playerBullets.push({ x: player.x, y: player.y - 15, dx: Math.cos(angle), dy: Math.sin(angle), speed: 10 + level * 0.5, damage: novaDmg, type: 'spread', color: '#ffff00' });
                    }
                    // Wingman nova at level 5+
                    if (level >= 5) {
                        const wingCount = 2 + Math.floor((level - 5) / 2);
                        [-35, 35].forEach(offset => {
                            for (let i = 0; i < wingCount; i++) {
                                const angle = -Math.PI/2 + (i - (wingCount-1)/2) * 0.2;
                                playerBullets.push({ x: player.x + offset, y: player.y + 5, dx: Math.cos(angle), dy: Math.sin(angle), speed: 9, damage: novaDmg * 0.5, type: 'spread', color: '#dddd00' });
                            }
                        });
                    }
                    playSound('shoot'); break;
                    
                case 'SWARM':
                    // Missile count: 2, 2, 3, 3, 4, 4, 5
                    const missileCount = 2 + Math.floor(level / 2);
                    const swarmDmg = 2 + level * 0.7;
                    for (let i = 0; i < missileCount; i++) {
                        playerBullets.push({ x: player.x + (i - (missileCount-1)/2) * 12, y: player.y - 10, dx: (Math.random() - 0.5) * 0.4, dy: -0.8, speed: 3, maxSpeed: 8 + level * 0.5, acceleration: 0.3 + level * 0.02, turnSpeed: 0.12 + level * 0.01, damage: swarmDmg, type: 'seeker', color: '#00ff00', target: null, trail: [] });
                    }
                    // Wingman missiles at level 5+
                    if (level >= 5) {
                        const wingMissiles = 1 + Math.floor((level - 5) / 2);
                        [-35, 35].forEach(offset => {
                            for (let j = 0; j < wingMissiles; j++) {
                                playerBullets.push({ x: player.x + offset, y: player.y + 5, dx: (Math.random() - 0.5) * 0.3, dy: -0.8, speed: 3, maxSpeed: 8, acceleration: 0.28, turnSpeed: 0.11, damage: swarmDmg * 0.5, type: 'seeker', color: '#00cc00', target: null, trail: [] });
                            }
                        });
                    }
                    playSound('shoot'); break;
            }
        }
        
        // ═══════════════════════════════════════
        // SPECIAL ATTACK
        // ═══════════════════════════════════════
        function useSpecialAttack() {
            if (specialAttacks <= 0 || !specialReady) return;
            specialAttacks--; specialReady = false;
            setTimeout(() => specialReady = true, 500);
            document.getElementById('specialCount').textContent = '×' + specialAttacks;
            if (specialAttacks <= 0) document.getElementById('specialBtn').disabled = true;
            playSound('special');
            enemyBullets = [];
            for (let i = enemies.length - 1; i >= 0; i--) { enemies[i].health -= 30; spawnParticles(enemies[i].x, enemies[i].y, '#ffff00', 6); if (enemies[i].health <= 0) handleEnemyDeath(enemies[i], i); }
            if (boss) { boss.health -= 80; spawnParticles(boss.x, boss.y, '#ffff00', 12); if (boss.health <= 0) handleBossDeath(); }
            particles.push({ type: 'flash', alpha: 0.7, duration: 12 });
            triggerScreenShake(15, 20);
            showNotification('BOMB!', '#ffff00');
        }
        
        // ═══════════════════════════════════════
        // ENEMY/BOSS DEATH HANDLERS (FIXED!)
        // ═══════════════════════════════════════
        function handleEnemyDeath(enemy, index) {
            score += enemy.points || 10;
            spawnParticles(enemy.x, enemy.y, '#ff6600', 8);
            playSound('explosion');
            if (enemy.hasPowerUp) spawnPowerUp(enemy.x, enemy.y);
            const wasMiniBoss = enemy.type === 'miniboss' || enemy.type === 'miniboss2';
            enemies.splice(index, 1);
            if (wasMiniBoss && !enemies.some(e => e.type === 'miniboss' || e.type === 'miniboss2')) {
                bossActive = false;
                advanceWave();
            }
        }
        
        function handleBossDeath() {
            if (!boss) return;
            score += boss.points || 1000;
            spawnParticles(boss.x, boss.y, '#ffff00', 25);
            playSound('explosion');
            particles.push({ type: 'flash', alpha: 0.9, duration: 15 });
            triggerScreenShake(20, 30);
            showNotification('BOSS DEFEATED!', '#ffd700');
            boss = null;
            bossActive = false;
            advanceWave();
        }
        
        function advanceWave() {
            if (waveTransitioning) return;
            wave++;
            if (wave > TOTAL_WAVES) { showVictory(); }
            else { waveTransitioning = true; setTimeout(() => initWave(wave), 1500); }
        }
        
        function spawnPowerUp(x, y) { const rand = Math.random(); let type = rand < 0.4 ? 'UPGRADE' : rand < 0.7 ? 'HEART' : rand < 0.85 ? 'BOMB' : 'SHIELD'; powerUps.push({ x, y, type, dy: 1.2 }); }
        function collectPowerUp(p) { playSound('powerup'); switch(p.type) { case 'UPGRADE': if (weaponLevel < MAX_WEAPON_LEVEL) { weaponLevel++; showNotification('POWER UP!', '#00ffff'); } else { score += 500; showNotification('+500', '#ffd700'); } break; case 'HEART': lives++; showNotification('+1 LIFE', '#ff4444'); break; case 'BOMB': specialAttacks = Math.min(specialAttacks + 1, 5); document.getElementById('specialCount').textContent = '×' + specialAttacks; document.getElementById('specialBtn').disabled = false; showNotification('+BOMB', '#ffaa00'); break; case 'SHIELD': shields = Math.min(shields + 1, 3); showNotification('+SHIELD', '#00aaff'); break; } updateUI(); }
        
        // ═══════════════════════════════════════
        // WAVE INIT (2X ENEMY HP!)
        // ═══════════════════════════════════════
        function initWave(waveNum) {
            enemies = []; boss = null; bossActive = false; waveTransitioning = false;
            document.getElementById('waveNum').textContent = waveNum;
            if (MAIN_BOSS_WAVES.includes(waveNum)) { mainBossLevel++; spawnMainBoss(mainBossLevel); }
            else if (MINI_BOSS_WAVES.includes(waveNum)) { spawnMiniBoss(DOUBLE_MINI_WAVES.includes(waveNum)); }
            else { spawnRegularWave(waveNum); }
            showNotification('WAVE ' + waveNum, '#00ffff');
        }
        
        function spawnMainBoss(level) {
            bossActive = true;
            const health = (250 + level * 100) * 2; // 2X HP!
            const size = BOSS_SIZES[level] || BOSS_SIZES[1];
            boss = { x: 200, y: 90, width: size.w * 0.6, height: size.h * 0.6, health, maxHealth: health, type: 'mainboss', bossNum: level, points: 1500 + level * 500, fireTimer: 0, moveDir: 1, phase: 0, animTimer: 0 };
            playSound('explosion');
            showNotification('MAIN BOSS!', '#ff0000');
        }
        
        function spawnMiniBoss(isDouble) {
            bossActive = true;
            const count = isDouble ? 2 : 1;
            for (let i = 0; i < count; i++) {
                const health = (100 + wave * 4) * 2; // 2X HP!
                enemies.push({ x: isDouble ? (i === 0 ? 120 : 280) : 200, y: 70, width: 70, height: 70, health, maxHealth: health, type: i === 0 ? 'miniboss' : 'miniboss2', points: 400, fireTimer: Math.random() * 30, moveDir: i === 0 ? 1 : -1 });
            }
            showNotification(isDouble ? 'TWIN BOSSES!' : 'MINI BOSS!', '#e8707e');
        }
        
        function spawnRegularWave(waveNum) {
            const difficulty = Math.floor(waveNum / 4);
            const enemyCount = 5 + waveNum + difficulty * 2;
            for (let i = 0; i < enemyCount; i++) {
                const row = Math.floor(i / 6), col = i % 6;
                const x = 55 + col * 55, y = 55 + row * 50;
                let type = PAWN;
                const rand = Math.random();
                if (waveNum >= 17 && rand < 0.15) type = CHARGER;
                else if (waveNum >= 13 && rand < 0.2) type = BOUNCER;
                else if (waveNum >= 6 && rand < 0.25) type = BUBBLE_SHOOTER;
                else if (waveNum >= 3 && rand < 0.35) type = KNIGHT;
                
                let health, points;
                switch(type) {
                    case PAWN: health = (6 + difficulty * 2) * 2; points = 10; break; // 2X HP!
                    case KNIGHT: health = (12 + difficulty * 4) * 2; points = 25; break;
                    case BUBBLE_SHOOTER: health = (10 + difficulty * 2) * 2; points = 30; break;
                    case BOUNCER: health = (30 + difficulty * 6) * 2; points = 50; break;
                    case CHARGER: health = (24 + difficulty * 4) * 2; points = 40; break;
                }
                enemies.push({ x, y, type, health, points, width: type === BOUNCER ? 28 : 22, height: type === BOUNCER ? 28 : 26, moveDir: i % 2 === 0 ? 1 : -1, fireTimer: Math.random() * 100, hasPowerUp: Math.random() < 0.18, dx: type === BOUNCER ? (Math.random() - 0.5) * 3 : 0, dy: type === BOUNCER ? Math.random() * 2 + 1 : 0, charging: false, chargeTimer: 0 });
            }
        }
        
        // ═══════════════════════════════════════
        // UPDATE (with all freeze fixes)
        // ═══════════════════════════════════════
        function update(dt) {
            if (!gameStarted || gameOver || victory) return;
            
            const speed = 5.5;
            if (keys.left) player.x -= speed;
            if (keys.right) player.x += speed;
            player.x = Math.max(20, Math.min(380, player.x));
            
            if (playerInvulnerable) { invulnerableTimer--; if (invulnerableTimer <= 0) playerInvulnerable = false; }
            if (screenShake > 0) screenShake--;
            
            if (currentWeapon === 'LASER') { if (!laserActive) { laserActive = true; startLaserSound(); } }
            else { if (laserActive) { laserActive = false; stopLaserSound(); } fireWeapon(); }
            
            if (keys.special) { useSpecialAttack(); keys.special = false; }
            
            updateStars(); updateParticles(); updateNotifications();
            
            // Update player bullets
            for (let i = playerBullets.length - 1; i >= 0; i--) {
                const b = playerBullets[i];
                if (b.type === 'seeker') {
                    if (b.speed < b.maxSpeed) b.speed += b.acceleration;
                    if (!b.target || (b.target.health !== undefined && b.target.health <= 0)) {
                        b.target = null; let bestDist = Infinity;
                        enemies.forEach(e => { const d = Math.hypot(e.x - b.x, e.y - b.y); if (d < bestDist && e.y < b.y + 60) { bestDist = d; b.target = e; } });
                        if (boss) { const d = Math.hypot(boss.x - b.x, boss.y - b.y); if (d < bestDist) b.target = boss; }
                    }
                    if (b.target) { const angle = Math.atan2(b.target.y - b.y, b.target.x - b.x), currentAngle = Math.atan2(b.dy, b.dx); let diff = angle - currentAngle; while (diff > Math.PI) diff -= Math.PI * 2; while (diff < -Math.PI) diff += Math.PI * 2; const newAngle = currentAngle + Math.sign(diff) * Math.min(Math.abs(diff), b.turnSpeed); b.dx = Math.cos(newAngle); b.dy = Math.sin(newAngle); }
                    b.trail.push({ x: b.x, y: b.y }); if (b.trail.length > 8) b.trail.shift();
                }
                b.x += (b.dx || 0) * b.speed; b.y += b.dy * b.speed;
                if (b.y < -20 || b.y > 520 || b.x < -20 || b.x > 420) playerBullets.splice(i, 1);
            }
            
            // Update enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                if (e.type === 'miniboss' || e.type === 'miniboss2') {
                    e.x += e.moveDir * 1.8 * gameSpeed; if (e.x < 60 || e.x > 340) e.moveDir *= -1;
                    e.fireTimer++;
                    if (e.fireTimer > 50) { e.fireTimer = 0; const angle = Math.atan2(player.y - e.y, player.x - e.x); enemyBullets.push({ x: e.x, y: e.y + 25, dx: Math.cos(angle) * 3.5, dy: Math.sin(angle) * 3.5 }); if (Math.random() < 0.3) { enemyBullets.push({ x: e.x - 20, y: e.y + 15, dx: 0, dy: 4 }); enemyBullets.push({ x: e.x + 20, y: e.y + 15, dx: 0, dy: 4 }); } }
                } else if (e.type === BOUNCER) {
                    e.x += e.dx * gameSpeed; e.y += e.dy * gameSpeed;
                    if (e.x < 25 || e.x > 375) e.dx *= -1;
                    if (e.y < 50 || e.y > 280) e.dy *= -1;
                } else if (e.type === CHARGER) {
                    e.chargeTimer++;
                    if (e.charging) { e.y += 9 * gameSpeed; if (e.y > 520) { e.y = 50; e.charging = false; e.chargeTimer = 0; } }
                    else { e.x += e.moveDir * 1.2 * gameSpeed; if (e.x < 35 || e.x > 365) e.moveDir *= -1; if (e.chargeTimer > 100 && Math.abs(e.x - player.x) < 40) e.charging = true; }
                } else {
                    e.x += e.moveDir * 0.6 * gameSpeed; if (e.x < 35 || e.x > 365) e.moveDir *= -1;
                    e.fireTimer++;
                    const fireRate = e.type === BUBBLE_SHOOTER ? 100 : 150;
                    if (e.fireTimer > fireRate && Math.random() < 0.025) { e.fireTimer = 0; if (e.type === BUBBLE_SHOOTER) { enemyBullets.push({ x: e.x, y: e.y + 15, dx: 0, dy: 2.5, isBubble: true, size: 12 }); } else { enemyBullets.push({ x: e.x, y: e.y + 14, dx: (player.x - e.x) * 0.012, dy: 3.5 }); } }
                }
                
                // Bullet collision
                for (let bi = playerBullets.length - 1; bi >= 0; bi--) {
                    const b = playerBullets[bi];
                    if (Math.abs(b.x - e.x) < e.width/2 + 6 && Math.abs(b.y - e.y) < e.height/2 + 6) {
                        const weapon = b.type === 'volt' ? 'RAILGUN' : b.type === 'seeker' ? 'SWARM' : b.type === 'spread' ? 'NOVA' : 'RAILGUN';
                        const mult = getDamageMultiplier(weapon, e);
                        e.health -= b.damage * mult;
                        spawnHitSparkles(b.x, b.y, mult > 1 ? '#ffff00' : WEAPONS[weapon].color);
                        playerBullets.splice(bi, 1);
                        if (e.health <= 0) { handleEnemyDeath(e, i); break; }
                    }
                }
                
                // Player collision
                if (!playerInvulnerable && enemies[i] && Math.abs(e.x - player.x) < e.width/2 + 12 && Math.abs(e.y - player.y) < e.height/2 + 12) loseLife();
            }
            
            // LASER DAMAGE (balanced)
            if (laserActive && currentWeapon === 'LASER') {
                const laserWidth = 6 + weaponLevel * 3;
                const baseDamage = 0.35 + weaponLevel * 0.12;
                
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const e = enemies[i];
                    if (Math.abs(e.x - player.x) < laserWidth * 1.2 + e.width/2 && e.y < player.y) {
                        const mult = getDamageMultiplier('LASER', e);
                        e.health -= baseDamage * mult;
                        if (Math.random() < 0.1) spawnHitSparkles(e.x, e.y, mult > 1 ? '#ffff00' : '#ff00ff');
                        if (e.health <= 0) handleEnemyDeath(e, i);
                    }
                }
                
                if (weaponLevel >= 5) {
                    const wingLaserWidth = laserWidth * 0.4;
                    [-35, 35].forEach(offset => {
                        for (let i = enemies.length - 1; i >= 0; i--) {
                            const e = enemies[i];
                            if (Math.abs(e.x - (player.x + offset)) < wingLaserWidth + e.width/2 && e.y < player.y + 15) {
                                const mult = getDamageMultiplier('LASER', e);
                                e.health -= baseDamage * 0.3 * mult;
                                if (e.health <= 0) handleEnemyDeath(e, i);
                            }
                        }
                    });
                }
                
                if (boss && Math.abs(boss.x - player.x) < laserWidth * 1.2 + boss.width/2) {
                    const mult = getDamageMultiplier('LASER', boss);
                    boss.health -= baseDamage * 0.7 * mult;
                    if (Math.random() < 0.06) spawnHitSparkles(boss.x + (Math.random()-0.5)*30, boss.y + (Math.random()-0.5)*20, '#ff00ff');
                    if (boss.health <= 0) handleBossDeath();
                }
                
                if (boss && weaponLevel >= 5) {
                    const wingLaserWidth = laserWidth * 0.4;
                    [-35, 35].forEach(offset => {
                        if (boss && Math.abs(boss.x - (player.x + offset)) < wingLaserWidth + boss.width/2) {
                            const mult = getDamageMultiplier('LASER', boss);
                            boss.health -= baseDamage * 0.2 * mult;
                        }
                    });
                    if (boss && boss.health <= 0) handleBossDeath();
                }
            }
            
            // Update boss
            if (boss) {
                boss.x += boss.moveDir * 2.2 * gameSpeed;
                if (boss.x < 90 || boss.x > 310) boss.moveDir *= -1;
                boss.fireTimer++;
                if (boss.fireTimer > 35) {
                    boss.fireTimer = 0;
                    const pattern = Math.floor(Math.random() * 4);
                    if (pattern === 0) { const angle = Math.atan2(player.y - boss.y, player.x - boss.x); enemyBullets.push({ x: boss.x, y: boss.y + boss.height/2, dx: Math.cos(angle) * 4.5, dy: Math.sin(angle) * 4.5 }); }
                    else if (pattern === 1) { for (let i = -2; i <= 2; i++) enemyBullets.push({ x: boss.x, y: boss.y + boss.height/2, dx: i * 1.8, dy: 4.5 }); }
                    else if (pattern === 2) { enemyBullets.push({ x: boss.x, y: boss.y + boss.height/2, dx: 0, dy: 3, isBubble: true, size: 16 }); }
                    else { enemyBullets.push({ x: boss.x - 25, y: boss.y + boss.height/2, dx: -1, dy: 4 }); enemyBullets.push({ x: boss.x + 25, y: boss.y + boss.height/2, dx: 1, dy: 4 }); }
                }
                
                for (let bi = playerBullets.length - 1; bi >= 0; bi--) {
                    const b = playerBullets[bi];
                    if (Math.abs(b.x - boss.x) < boss.width/2 + 8 && Math.abs(b.y - boss.y) < boss.height/2 + 8) {
                        const weapon = b.type === 'volt' ? 'RAILGUN' : b.type === 'seeker' ? 'SWARM' : b.type === 'spread' ? 'NOVA' : 'RAILGUN';
                        const mult = getDamageMultiplier(weapon, boss);
                        boss.health -= b.damage * mult;
                        spawnHitSparkles(b.x, b.y, mult > 1 ? '#ffff00' : WEAPONS[weapon].color);
                        playerBullets.splice(bi, 1);
                        if (boss.health <= 0) { handleBossDeath(); break; }
                    }
                }
            }
            
            // Update enemy bullets
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const b = enemyBullets[i];
                b.x += b.dx || 0; b.y += b.dy || 3.5;
                if (b.y > 520 || b.y < -20 || b.x < -20 || b.x > 420) { enemyBullets.splice(i, 1); continue; }
                if (!playerInvulnerable) {
                    const hitSize = b.isBubble ? (b.size || 10) + 8 : b.isOrangeBall ? (b.size || 14) + 6 : 12;
                    if (Math.abs(b.x - player.x) < hitSize && Math.abs(b.y - player.y) < hitSize) { enemyBullets.splice(i, 1); loseLife(); }
                }
            }
            
            // Pop bubbles
            for (let bi = playerBullets.length - 1; bi >= 0; bi--) {
                const b = playerBullets[bi];
                for (let ei = enemyBullets.length - 1; ei >= 0; ei--) {
                    const eb = enemyBullets[ei];
                    if (eb.isBubble && Math.abs(b.x - eb.x) < (eb.size || 10) + 6 && Math.abs(b.y - eb.y) < (eb.size || 10) + 6) { spawnHitSparkles(eb.x, eb.y, '#ff3366'); enemyBullets.splice(ei, 1); score += 5; break; }
                }
            }
            
            // Update power-ups
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const p = powerUps[i]; p.y += p.dy;
                if (Math.abs(p.x - player.x) < 22 && Math.abs(p.y - player.y) < 22) { collectPowerUp(p); powerUps.splice(i, 1); continue; }
                if (p.y > 520) powerUps.splice(i, 1);
            }
            
            // Check wave complete
            if (!bossActive && !waveTransitioning && enemies.length === 0 && !boss) advanceWave();
            
            updateUI();
        }
        
        // ═══════════════════════════════════════
        // DRAW
        // ═══════════════════════════════════════
        function draw() {
            ctx.save();
            if (screenShake > 0) ctx.translate((Math.random() - 0.5) * screenShakeIntensity, (Math.random() - 0.5) * screenShakeIntensity);
            ctx.fillStyle = '#050510'; ctx.fillRect(0, 0, 400, 500);
            drawStars();
            enemies.forEach((e, i) => {
                if (e.type === PAWN) drawPawn(e.x, e.y);
                else if (e.type === KNIGHT) drawKnight(e.x, e.y);
                else if (e.type === BUBBLE_SHOOTER) drawBubbleShooter(e.x, e.y);
                else if (e.type === BOUNCER) drawBouncer(e.x, e.y, e);
                else if (e.type === CHARGER) drawCharger(e.x, e.y, e);
                else if (e.type === 'miniboss' || e.type === 'miniboss2') drawMiniBoss(e);
                if (e.hasPowerUp) { ctx.fillStyle = '#ffd700'; ctx.beginPath(); ctx.arc(e.x, e.y - e.height, 4, 0, Math.PI * 2); ctx.fill(); }
                if ((e.type === BOUNCER || e.type === CHARGER) && e.health > 0) { const maxHp = e.type === BOUNCER ? 72 : 56; ctx.fillStyle = '#333'; ctx.fillRect(e.x - 12, e.y - 22, 24, 4); ctx.fillStyle = e.health > maxHp * 0.3 ? '#0f0' : '#f00'; ctx.fillRect(e.x - 12, e.y - 22, 24 * Math.min(1, e.health / maxHp), 4); }
            });
            if (boss) drawBoss();
            drawPlayer(); drawShields(); drawBullets(); drawPowerUps(); drawParticles(); drawNotifications();
            if (bossActive) { ctx.fillStyle = MAIN_BOSS_WAVES.includes(wave) ? '#ffaa00' : '#e8707e'; ctx.font = 'bold 13px Courier New'; ctx.textAlign = 'center'; ctx.fillText(MAIN_BOSS_WAVES.includes(wave) ? '⚔ MAIN BOSS ⚔' : DOUBLE_MINI_WAVES.includes(wave) ? '⚔ TWIN BOSSES ⚔' : '⚔ MINI BOSS ⚔', 200, 28); }
            ctx.restore();
        }
        
        function gameLoop(timestamp) { frameTime = timestamp; update(timestamp - lastTime); lastTime = timestamp; draw(); requestAnimationFrame(gameLoop); }
        function triggerScreenShake(intensity, duration) { screenShake = duration; screenShakeIntensity = intensity; }
        
        function loseLife() {
            if (playerInvulnerable) return;
            if (shields > 0) { shields--; showNotification('SHIELD LOST', '#00aaff'); spawnParticles(player.x, player.y, '#00aaff', 8); triggerScreenShake(6, 12); playSound('playerHit'); updateUI(); return; }
            lives--;
            if (weaponLevel > 1) { weaponLevel--; showNotification('POWER DOWN', '#ff8800'); }
            spawnParticles(player.x, player.y, '#e8707e', 12); triggerScreenShake(14, 22); playSound('playerHit');
            particles.push({ type: 'flash', alpha: 0.5, duration: 10 });
            playerInvulnerable = true; invulnerableTimer = 70;
            if (lives <= 0) { stopMusic(); showGameOver(); } else showNotification('DAMAGE!', '#ff4444');
            updateUI();
        }
        
        function updateUI() {
            document.getElementById('score').textContent = score;
            let hearts = '♥'.repeat(Math.min(lives, 10)); if (lives > 10) hearts += '+' + (lives - 10);
            document.getElementById('livesDisplay').innerHTML = hearts;
            const powerBar = document.getElementById('powerBar'), powerLabel = document.getElementById('powerLabel');
            powerBar.style.width = (weaponLevel / MAX_WEAPON_LEVEL * 100) + '%';
            if (weaponLevel >= 5) { powerBar.classList.add('maxed'); powerLabel.className = 'rabbit-mode'; powerLabel.textContent = 'RABBIT MODE'; }
            else { powerBar.classList.remove('maxed'); powerLabel.className = 'power-label'; powerLabel.textContent = 'PWR'; }
        }
        
        function showGameOver() { gameOver = true; stopMusic(); stopLaserSound(); laserActive = false; document.getElementById('finalScore').textContent = score; document.getElementById('gameOverScreen').classList.remove('hidden'); document.getElementById('weaponHudLeft').classList.add('hidden'); document.getElementById('weaponHudRight').classList.add('hidden'); }
        function showVictory() { victory = true; stopMusic(); stopLaserSound(); laserActive = false; document.getElementById('victoryScore').textContent = score; if (newGamePlusLevel > 0) document.getElementById('continueBtn').textContent = 'NG+' + (newGamePlusLevel + 1) + '?'; document.getElementById('victoryScreen').classList.remove('hidden'); document.getElementById('weaponHudLeft').classList.add('hidden'); document.getElementById('weaponHudRight').classList.add('hidden'); }
        
        function continueToNewGamePlus() {
            newGamePlusLevel++; victory = false; gameSpeed += 0.18; wave = 1; mainBossLevel = 0; waveTransitioning = false;
            playerBullets = []; enemyBullets = []; powerUps = []; particles = [];
            specialAttacks = Math.min(specialAttacks + 2, 5);
            document.getElementById('specialCount').textContent = '×' + specialAttacks;
            document.getElementById('specialBtn').disabled = false;
            document.getElementById('victoryScreen').classList.add('hidden');
            document.getElementById('weaponHudLeft').classList.remove('hidden');
            document.getElementById('weaponHudRight').classList.remove('hidden');
            showNotification('CYCLE ' + newGamePlusLevel + ' INITIATED', '#ff00ff');
            startMusic(); initWave(1); updateUI();
        }
        
        function restartGame() {
            gameStarted = true; gameOver = false; victory = false; waveTransitioning = false;
            score = 0; lives = 5; wave = 1; gameSpeed = 1.0; newGamePlusLevel = 0; mainBossLevel = 0;
            currentWeapon = 'RAILGUN'; weaponLevel = 1; specialAttacks = 3; specialReady = true; shields = 0;
            player.x = 200; playerBullets = []; enemyBullets = []; powerUps = []; particles = []; notifications = [];
            playerInvulnerable = false; invulnerableTimer = 0; laserActive = false; bossActive = false; boss = null;
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('victoryScreen').classList.add('hidden');
            document.getElementById('weaponHudLeft').classList.remove('hidden');
            document.getElementById('weaponHudRight').classList.remove('hidden');
            document.getElementById('specialCount').textContent = '×3';
            document.getElementById('specialBtn').disabled = false;
            startMusic(); updateUI(); updateWeaponButtonDisplay(); initWave(1);
        }
        
        function startGame() {
            if (gameStarted) return;
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('weaponHudLeft').classList.remove('hidden');
            document.getElementById('weaponHudRight').classList.remove('hidden');
            gameStarted = true; lives = 5; currentWeapon = 'RAILGUN'; weaponLevel = 1;
            initAudio(); startMusic(); initWave(1); updateUI(); updateWeaponButtonDisplay();
        }
        
        // ═══════════════════════════════════════
        // INPUT
        // ═══════════════════════════════════════
        document.addEventListener('keydown', (e) => {
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
            if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
            if (e.code === 'Space') { e.preventDefault(); if (!gameStarted) startGame(); else keys.special = true; }
            if (e.code === 'Escape') toggleSettingsMenu();
            const wmap = { Digit1: 'RAILGUN', Digit2: 'LASER', Digit3: 'NOVA', Digit4: 'SWARM' };
            if (wmap[e.code]) { if (currentWeapon === 'LASER' && wmap[e.code] !== 'LASER') { stopLaserSound(); laserActive = false; } currentWeapon = wmap[e.code]; playSound('weaponSwitch'); updateWeaponButtonDisplay(); showNotification(WEAPONS[currentWeapon].name + ' LV.' + weaponLevel, WEAPONS[currentWeapon].color); }
            if (e.code === 'KeyQ') switchWeapon(-1);
            if (e.code === 'KeyE') switchWeapon(1);
        });
        document.addEventListener('keyup', (e) => { if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false; if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false; if (e.code === 'Space') keys.special = false; });
        
        document.getElementById('startScreen').addEventListener('click', startGame);
        document.getElementById('startScreen').addEventListener('touchstart', (e) => { e.preventDefault(); startGame(); }, { passive: false });
        
        const leftBtn = document.getElementById('leftBtn'), rightBtn = document.getElementById('rightBtn'), specialBtn = document.getElementById('specialBtn');
        function setupMoveBtn(btn, key) {
            btn.addEventListener('touchstart', (e) => { e.preventDefault(); keys[key] = true; btn.classList.add('active'); }, { passive: false });
            btn.addEventListener('touchend', () => { keys[key] = false; btn.classList.remove('active'); });
            btn.addEventListener('touchcancel', () => { keys[key] = false; btn.classList.remove('active'); });
            btn.addEventListener('mousedown', () => keys[key] = true);
            btn.addEventListener('mouseup', () => keys[key] = false);
            btn.addEventListener('mouseleave', () => keys[key] = false);
        }
        setupMoveBtn(leftBtn, 'left'); setupMoveBtn(rightBtn, 'right');
        specialBtn.addEventListener('touchstart', (e) => { e.preventDefault(); keys.special = true; }, { passive: false });
        specialBtn.addEventListener('click', () => keys.special = true);
        
        const weaponButtons = document.querySelectorAll('.weapon-btn');
        function selectWeapon(weaponKey) { if (currentWeapon === 'LASER' && weaponKey !== 'LASER') { stopLaserSound(); laserActive = false; } currentWeapon = weaponKey; playSound('weaponSwitch'); updateWeaponButtonDisplay(); showNotification(WEAPONS[currentWeapon].name + ' LV.' + weaponLevel, WEAPONS[currentWeapon].color); }
        function updateWeaponButtonDisplay() { weaponButtons.forEach(btn => { const weapon = btn.dataset.weapon, statusEl = btn.querySelector('.weapon-status'); if (weapon === currentWeapon) { btn.classList.add('active'); statusEl.textContent = 'ACTIVE'; } else { btn.classList.remove('active'); statusEl.textContent = 'READY'; } }); }
        weaponButtons.forEach(btn => { btn.addEventListener('touchstart', (e) => { e.preventDefault(); selectWeapon(btn.dataset.weapon); }, { passive: false }); btn.addEventListener('click', () => selectWeapon(btn.dataset.weapon)); });
        
        let menuOpen = false;
        function toggleSettingsMenu() { menuOpen = !menuOpen; document.getElementById('settingsMenu').classList.toggle('open', menuOpen); }
        document.getElementById('settingsBtn').addEventListener('click', toggleSettingsMenu);
        document.getElementById('musicToggle').addEventListener('click', function() { musicEnabled = !musicEnabled; this.classList.toggle('active', musicEnabled); if (musicEnabled && gameStarted && !gameOver && !victory) startMusic(); else stopMusic(); });
        document.getElementById('soundToggle').addEventListener('click', function() { soundEnabled = !soundEnabled; this.classList.toggle('active', soundEnabled); if (!soundEnabled) stopLaserSound(); });
        
        document.body.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
        
        updateWeaponButtonDisplay();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
