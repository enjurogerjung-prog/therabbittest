<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>M.A.R.A. - DIVISION 4 ARCADE</title>
    <style>
        /* MONOCHROME THEME - Colors only for attacks */
        :root { --rabbit: #c0c0c0; --cyan: #00ffff; --gold: #888888; --bg-dark: #080808; }
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; -webkit-tap-highlight-color: transparent; }
        html, body { height: 100%; height: 100dvh; overflow: hidden; background: var(--bg-dark); }
        body { display: flex; flex-direction: column; align-items: center; justify-content: flex-start; font-family: 'Courier New', monospace; color: #fff; touch-action: none; padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left); padding-top: max(4px, env(safe-area-inset-top)); padding-bottom: max(4px, env(safe-area-inset-bottom)); }
        .game-container { position: relative; display: flex; flex-direction: column; align-items: center; width: 100%; max-width: 400px; height: 100%; max-height: 100dvh; }
        .game-header { display: flex; justify-content: space-between; align-items: center; width: 100%; padding: 8px 12px; font-size: 0.65rem; color: rgba(200, 200, 200, 0.8); text-transform: uppercase; letter-spacing: 0.12em; background: rgba(10, 10, 10, 0.95); border-bottom: 1px solid rgba(150, 150, 150, 0.25); flex-shrink: 0; gap: 12px; }
        .power-bar-container { position: relative; flex: 1; max-width: 140px; height: 10px; background: rgba(100, 100, 100, 0.1); border: 1px solid rgba(150, 150, 150, 0.3); border-radius: 2px; overflow: hidden; }
        .power-bar { height: 100%; width: 14.28%; background: linear-gradient(90deg, rgba(180, 180, 180, 0.6), rgba(220, 220, 220, 0.9)); transition: width 0.3s ease; }
        .power-bar.maxed { background: linear-gradient(90deg, rgba(240, 240, 240, 0.8), rgba(255, 255, 255, 0.95)); animation: powerPulse 0.5s ease-in-out infinite alternate; }
        @keyframes powerPulse { from { opacity: 0.8; } to { opacity: 1; } }
        .power-label { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 0.4rem; color: rgba(255, 255, 255, 0.6); letter-spacing: 0.15em; pointer-events: none; }
        .rabbit-mode { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 0.35rem; color: rgba(255, 255, 255, 1); letter-spacing: 0.1em; white-space: nowrap; animation: rabbitBlink 0.4s ease-in-out infinite; }
        @keyframes rabbitBlink { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }
        .lives-display { color: rgba(220, 220, 220, 0.9); font-size: 0.7rem; letter-spacing: 2px; }
        .game-title { text-align: center; padding: 8px 0; flex-shrink: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .game-title h1 { font-size: 1rem; font-weight: 400; color: rgba(255, 255, 255, 0.9); letter-spacing: 0.4em; margin: 0; padding-right: 0.4em; }
        .game-title .subtitle { font-size: 0.45rem; color: rgba(180, 180, 180, 0.5); letter-spacing: 0.2em; margin-top: 3px; }
        .canvas-wrapper { position: relative; width: 100%; max-width: 400px; flex: 1; min-height: 0; display: flex; align-items: center; justify-content: center; }
        #gameCanvas { display: block; max-width: 100%; max-height: 100%; border: 1px solid rgba(150, 150, 150, 0.3); background: var(--bg-dark); }
        .crt-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; background: repeating-linear-gradient(0deg, rgba(0,0,0,0.03) 0px, rgba(0,0,0,0.03) 1px, transparent 1px, transparent 2px); opacity: 0.5; }
        .weapon-hud { position: absolute; top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; gap: 3px; z-index: 15; pointer-events: auto; }
        .weapon-hud.left { left: 0; }
        .weapon-hud.right { right: 0; }
        .weapon-btn { padding: 10px 18px; min-width: 70px; background: rgba(100, 100, 100, 0.06); border: 1px solid rgba(150, 150, 150, 0.2); color: rgba(180, 180, 180, 0.4); font-family: 'Courier New', monospace; font-size: 0.6rem; letter-spacing: 0.2em; cursor: pointer; text-transform: uppercase; -webkit-tap-highlight-color: transparent; user-select: none; }
        .weapon-btn .weapon-label { display: block; }
        .weapon-btn .weapon-status { display: block; font-size: 0.45rem; margin-top: 3px; opacity: 0.5; }
        .weapon-hud.left .weapon-btn { border-left: none; border-radius: 0 3px 3px 0; text-align: left; }
        .weapon-hud.right .weapon-btn { border-right: none; border-radius: 3px 0 0 3px; text-align: right; }
        .weapon-btn:active { background: rgba(180, 180, 180, 0.12); }
        .weapon-btn.active { background: rgba(255, 255, 255, 0.08); border-color: rgba(255, 255, 255, 0.4); color: rgba(255, 255, 255, 0.95); }
        .weapon-btn.active .weapon-status { color: rgba(220, 220, 220, 0.9); opacity: 1; }
        @media (max-height: 600px) { .weapon-hud { gap: 2px; } .weapon-btn { padding: 6px 12px; min-width: 55px; font-size: 0.5rem; } .weapon-btn .weapon-status { font-size: 0.4rem; margin-top: 2px; } }
        .mobile-controls { display: flex; width: 100%; max-width: 400px; gap: 6px; padding: 6px; box-sizing: border-box; flex-shrink: 0; background: rgba(10, 10, 10, 0.8); border-top: 1px solid rgba(150, 150, 150, 0.2); }
        .control-btn { background: rgba(100, 100, 100, 0.06); border: 1px solid rgba(150, 150, 150, 0.3); color: rgba(180, 180, 180, 0.7); font-family: 'Courier New', monospace; border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; -webkit-tap-highlight-color: transparent; user-select: none; }
        .control-btn:active, .control-btn.active { background: rgba(255, 255, 255, 0.15); border-color: rgba(255, 255, 255, 0.6); color: rgba(255, 255, 255, 0.95); transform: scale(0.97); }
        .move-btn { flex: 1; height: 65px; font-size: 1.5rem; }
        .bomb-btn { flex: 0.8; height: 65px; background: rgba(150, 150, 150, 0.08); border-color: rgba(180, 180, 180, 0.4); color: rgba(200, 200, 200, 0.8); flex-direction: column; gap: 2px; }
        .bomb-btn .btn-label { font-size: 0.55rem; }
        .bomb-btn .btn-icon { font-size: 0.7rem; opacity: 0.7; }
        .bomb-btn:disabled { opacity: 0.25; }
        .desktop-controls { margin-top: 10px; text-align: center; color: rgba(180, 180, 180, 0.4); font-size: 0.55rem; }
        @media (max-width: 500px) { .desktop-controls { display: none; } }
        @media (min-width: 501px) { .mobile-controls { display: none; } }
        .overlay-screen { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(180deg, rgba(10, 10, 15, 0.98), rgba(15, 15, 20, 0.98)); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 10; padding: 20px; gap: 12px; text-align: center; }
        .hidden { display: none !important; }
        .overlay-screen h2 { font-size: 1.8rem; color: #e0e0e0; letter-spacing: 0.35em; margin: 0; font-weight: 400; }
        .overlay-screen p { font-size: 0.5rem; color: #888; letter-spacing: 0.2em; margin: 0; text-transform: uppercase; }
        .overlay-screen .story { font-size: 0.75rem; color: #aaa; text-align: center; max-width: 260px; line-height: 1.7; margin: 10px 0; }
        .overlay-screen .controls-info { background: rgba(150, 150, 150, 0.05); border: 1px solid rgba(150, 150, 150, 0.15); border-radius: 8px; padding: 14px 20px; display: flex; flex-direction: column; gap: 8px; font-size: 0.55rem; color: rgba(180, 180, 180, 0.7); letter-spacing: 0.1em; margin-top: 5px; }
        .overlay-screen .blink { font-size: 0.75rem; color: #fff; letter-spacing: 0.35em; margin-top: 18px; animation: blink 1s infinite; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
        .logo { margin-bottom: 15px; }
        .logo img { width: 80px; height: 80px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.5); }
        .btn-restart { background: rgba(200, 200, 200, 0.15); border: 1px solid #c0c0c0; color: #d0d0d0; padding: 10px 24px; font-family: 'Courier New', monospace; font-size: 0.75rem; letter-spacing: 0.2em; cursor: pointer; margin-top: 12px; border-radius: 4px; }
        .settings-toggle { position: absolute; top: 8px; right: 8px; width: 32px; height: 32px; background: rgba(0, 0, 0, 0.5); border: 1px solid rgba(150, 150, 150, 0.3); border-radius: 4px; color: rgba(180, 180, 180, 0.7); font-size: 1rem; cursor: pointer; z-index: 20; display: flex; align-items: center; justify-content: center; }
        .settings-menu { position: absolute; top: 45px; right: 8px; background: rgba(15, 15, 20, 0.95); border: 1px solid rgba(150, 150, 150, 0.3); border-radius: 6px; padding: 12px; z-index: 20; display: none; flex-direction: column; gap: 10px; min-width: 140px; }
        .settings-menu.open { display: flex; }
        .setting-row { display: flex; justify-content: space-between; align-items: center; font-size: 0.65rem; color: rgba(180, 180, 180, 0.8); }
        .toggle-btn { width: 40px; height: 22px; background: rgba(100, 100, 100, 0.3); border: 1px solid rgba(150, 150, 150, 0.3); border-radius: 11px; cursor: pointer; position: relative; }
        .toggle-btn::after { content: ''; position: absolute; top: 2px; left: 2px; width: 16px; height: 16px; background: rgba(180, 180, 180, 0.6); border-radius: 50%; transition: left 0.2s; }
        .toggle-btn.active { background: rgba(255, 255, 255, 0.2); border-color: rgba(255, 255, 255, 0.5); }
        .toggle-btn.active::after { left: 20px; background: rgba(255, 255, 255, 0.9); }
        .settings-divider { height: 1px; background: rgba(150, 150, 150, 0.2); margin: 4px 0; }
        .settings-link { display: flex; align-items: center; justify-content: center; gap: 6px; padding: 8px 12px; background: rgba(100, 100, 100, 0.1); border: 1px solid rgba(150, 150, 150, 0.25); border-radius: 4px; color: rgba(200, 200, 200, 0.9); font-size: 0.6rem; text-decoration: none; letter-spacing: 0.1em; transition: all 0.2s; }
        .settings-link:hover { background: rgba(150, 150, 150, 0.2); border-color: rgba(200, 200, 200, 0.4); color: #fff; }
        .settings-link svg { width: 12px; height: 12px; fill: currentColor; }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <div class="power-bar-container">
                <div class="power-bar" id="powerBar"></div>
                <span class="power-label" id="powerLabel">PWR</span>
            </div>
            <div>SCORE <span id="score">0</span></div>
            <div class="lives-display" id="livesDisplay">♥♥♥♥♥</div>
        </div>
        <div class="game-title">
            <h1>M.A.R.A.</h1>
            <div class="subtitle">DIVISION 4 ARCADE</div>
        </div>
        <div class="canvas-wrapper">
            <canvas id="gameCanvas" width="400" height="500"></canvas>
            <div class="crt-overlay"></div>
            <div class="weapon-hud left" id="weaponHudLeft">
                <button class="weapon-btn active" data-weapon="RAILGUN"><span class="weapon-label">RAIL</span><span class="weapon-status">ACTIVE</span></button>
                <button class="weapon-btn" data-weapon="LASER"><span class="weapon-label">LASER</span><span class="weapon-status">READY</span></button>
            </div>
            <div class="weapon-hud right" id="weaponHudRight">
                <button class="weapon-btn" data-weapon="NOVA"><span class="weapon-label">NOVA</span><span class="weapon-status">READY</span></button>
                <button class="weapon-btn" data-weapon="SWARM"><span class="weapon-label">SWARM</span><span class="weapon-status">READY</span></button>
            </div>
            <button class="settings-toggle" id="settingsBtn">⚙</button>
            <div class="settings-menu" id="settingsMenu">
                <div class="setting-row"><span>Music</span><button class="toggle-btn active" id="musicToggle"></button></div>
                <div class="setting-row"><span>SFX</span><button class="toggle-btn active" id="soundToggle"></button></div>
                <div class="settings-divider"></div>
                <a href="https://rabbittest.io" class="settings-link">
                    <svg viewBox="0 0 24 24"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>
                    RABBITTEST.IO
                </a>
            </div>
            <div class="overlay-screen" id="startScreen">
                <div class="logo"><img src="data:image/png;base64,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" alt="M.A.R.A."></div>
                <h2>M.A.R.A.</h2>
                <p>MECHANICAL AUTONOMOUS RABBIT ARMAMENT</p>
                <div class="story">The herd has awakened.<br>Only you can stop them.</div>
                <div class="controls-info"><div>◄ ► MOVE</div><div>SIDE BUTTONS: WEAPONS</div><div>CENTER: BOMB</div></div>
                <div class="blink">TAP TO START</div>
            </div>
            <div class="overlay-screen hidden" id="gameOverScreen">
                <h2>GAME OVER</h2>
                <p>THE HERD PREVAILS</p>
                <div class="story">Final Score: <span id="finalScore">0</span></div>
                <button class="btn-restart" onclick="restartGame()">RETRY</button>
            </div>
            <div class="overlay-screen hidden" id="victoryScreen">
                <h2>VICTORY</h2>
                <p>THE HERD IS VANQUISHED</p>
                <div class="story">Score: <span id="victoryScore">0</span></div>
                <button class="btn-restart" id="continueBtn" onclick="continueToNewGamePlus()">NG+?</button>
                <button class="btn-restart" onclick="restartGame()">NEW GAME</button>
            </div>
        </div>
        <div class="mobile-controls">
            <button class="control-btn move-btn" id="leftBtn">◄</button>
            <button class="control-btn bomb-btn" id="specialBtn"><span class="btn-label">BOMB</span><span class="btn-icon" id="specialCount">×3</span></button>
            <button class="control-btn move-btn" id="rightBtn">►</button>
        </div>
        <div class="desktop-controls">A/D or ←/→ MOVE | 1-4 WEAPONS | Q/E CYCLE | SPACE BOMB</div>
    </div>

    <script>
        // ═══════════════════════════════════════
        // M.A.R.A. OPTIMIZED v3
        // - Boss sprites from GitHub
        // - Fixed freeze bugs (bossActive reset)
        // - Stronger weapons at max level
        // - 2x enemy HP
        // ═══════════════════════════════════════
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        
        let frameTime = 0, lastTime = 0;
        let gameStarted = false, gameOver = false, victory = false;
        let wave = 1, score = 0, lives = 5, gameSpeed = 1.0;
        let newGamePlusLevel = 0, waveTransitioning = false;
        let mainBossLevel = 0, bossActive = false;
        
        const player = { x: 200, y: 460, width: 24, height: 30 };
        let playerInvulnerable = false, invulnerableTimer = 0;
        
        // Audio
        let audioCtx = null, musicEnabled = true, soundEnabled = true;
        let musicOsc = null, musicGain = null;
        let laserOsc = null, laserGain = null, laserPlaying = false;
        let bgMusic = null;
        const MASTER_VOLUME = 0.5; // 50% quieter
        
        // Screen shake system
        let screenShake = { x: 0, y: 0, intensity: 0, duration: 0 };
        function addScreenShake(intensity, duration) {
            screenShake.intensity = Math.max(screenShake.intensity, intensity);
            screenShake.duration = Math.max(screenShake.duration, duration);
        }
        function updateScreenShake() {
            if (screenShake.duration > 0) {
                screenShake.x = (Math.random() - 0.5) * screenShake.intensity * 2;
                screenShake.y = (Math.random() - 0.5) * screenShake.intensity * 2;
                screenShake.duration--;
                screenShake.intensity *= 0.9;
            } else {
                screenShake.x = 0;
                screenShake.y = 0;
            }
        }
        
        // Damage numbers system
        function spawnDamageNumber(x, y, damage, isCrit = false) {
            damageNumbers.push({
                x: x + (Math.random() - 0.5) * 20,
                y: y,
                damage: Math.round(damage),
                life: 40,
                dy: -2,
                isCrit: isCrit,
                scale: isCrit ? 1.5 : 1
            });
        }
        function updateDamageNumbers() {
            for (let i = damageNumbers.length - 1; i >= 0; i--) {
                const d = damageNumbers[i];
                d.y += d.dy;
                d.dy += 0.05;
                d.life--;
                if (d.life <= 0) damageNumbers.splice(i, 1);
            }
        }
        function drawDamageNumbers() {
            damageNumbers.forEach(d => {
                ctx.save();
                ctx.globalAlpha = Math.min(1, d.life / 20);
                ctx.font = `bold ${12 * d.scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillStyle = d.isCrit ? '#ffffff' : '#cccccc';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeText(d.damage, d.x, d.y);
                ctx.fillText(d.damage, d.x, d.y);
                ctx.restore();
            });
        }
        
        // ═══════════════════════════════════════
        // BOSS SPRITE SYSTEM (from GitHub)
        // ═══════════════════════════════════════
        const BOSS_SPRITE_BASE = 'https://raw.githubusercontent.com/enjurogerjung-prog/therabbittest/main/';
        const bossSprites = {};
        let bossSpriteLoadCount = 0;
        [1,2,3,4].forEach(i => {
            bossSprites[i] = new Image();
            bossSprites[i].onload = () => { bossSpriteLoadCount++; };
            bossSprites[i].onerror = () => { console.log('Failed to load boss', i); };
            bossSprites[i].src = BOSS_SPRITE_BASE + 'boss' + i + '.jpg';
        });
        bossSprites[5] = new Image();
        bossSprites[5].onload = () => { bossSpriteLoadCount++; };
        bossSprites[5].onerror = () => { console.log('Failed to load boss 5'); };
        bossSprites[5].src = BOSS_SPRITE_BASE + 'TRUE%20LAST%20BOSS.png';
        
        const BOSS_SIZES = {
            1: { w: 108, h: 101 },
            2: { w: 116, h: 96 },
            3: { w: 91, h: 134 },
            4: { w: 286, h: 251 },
            5: { w: 225, h: 169 }
        };
        
        // Mini-boss sprite
        const miniBossSprite = new Image();
        miniBossSprite.src = 'https://raw.githubusercontent.com/enjurogerjung-prog/therabbittest/main/mecha_horse_miniboss.png';
        let miniBossSpriteLoaded = false;
        miniBossSprite.onload = () => { miniBossSpriteLoaded = true; };
        
        // ═══════════════════════════════════════
        // PARALLAX STARS
        // ═══════════════════════════════════════
        const farStars = [], midStars = [], nearStars = [];
        for (let i = 0; i < 40; i++) farStars.push({ x: Math.random() * 400, y: Math.random() * 500, size: 1, speed: 0.3, twinkle: Math.random() * Math.PI * 2 });
        for (let i = 0; i < 25; i++) midStars.push({ x: Math.random() * 400, y: Math.random() * 500, size: 1.5, speed: 0.8, color: ['#aaaaaa', '#888888', '#cccccc'][Math.floor(Math.random() * 3)] });
        for (let i = 0; i < 15; i++) nearStars.push({ x: Math.random() * 400, y: Math.random() * 500, size: 2, speed: 2, trail: 8 + Math.random() * 8 });
        
        function updateStars() {
            farStars.forEach(s => { s.y += s.speed * gameSpeed; if (s.y > 500) { s.y = 0; s.x = Math.random() * 400; } });
            midStars.forEach(s => { s.y += s.speed * gameSpeed; if (s.y > 500) { s.y = 0; s.x = Math.random() * 400; } });
            nearStars.forEach(s => { s.y += s.speed * gameSpeed; if (s.y > 500) { s.y = -s.trail; s.x = Math.random() * 400; } });
        }
        
        function drawStars() {
            const t = frameTime / 1000;
            farStars.forEach(s => { ctx.fillStyle = `rgba(255,255,255,${0.4 + Math.sin(t * 2 + s.twinkle) * 0.3})`; ctx.fillRect(s.x, s.y, s.size, s.size); });
            midStars.forEach(s => { ctx.fillStyle = s.color; ctx.globalAlpha = 0.7; ctx.fillRect(s.x, s.y, s.size, s.size); });
            ctx.globalAlpha = 1;
            nearStars.forEach(s => { ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(s.x, s.y - s.trail); ctx.lineTo(s.x, s.y); ctx.stroke(); ctx.fillStyle = '#fff'; ctx.fillRect(s.x - 1, s.y - 1, 2, 2); });
        }
        
        // ═══════════════════════════════════════
        // WEAPONS (STRONGER AT MAX LEVEL!)
        // ═══════════════════════════════════════
        const WEAPONS = {
            RAILGUN: { name: 'RAILGUN', color: '#00ffff', fireRate: 180 },
            LASER: { name: 'LASER', color: '#ff00ff', fireRate: 50 },
            NOVA: { name: 'NOVA', color: '#ffff00', fireRate: 280 },
            SWARM: { name: 'SWARM', color: '#00ff00', fireRate: 350 }
        };
        
        let currentWeapon = 'RAILGUN';
        let weaponLevel = 1;
        const MAX_WEAPON_LEVEL = 7;
        let specialAttacks = 3, specialReady = true, shields = 0;
        let laserActive = false;
        
        const WEAKNESSES = { 'pawn': 'NOVA', 'knight': 'RAILGUN', 'bubble': 'LASER', 'bouncer': 'SWARM', 'charger': 'NOVA', 'miniboss': 'LASER', 'miniboss2': 'LASER', 'mainboss': 'RAILGUN' };
        const BOSS_WEAKNESSES = { 1: 'RAILGUN', 2: 'NOVA', 3: 'SWARM', 4: 'LASER', 5: 'RAILGUN' };
        const WEAKNESS_MULTIPLIER = 2.5;
        
        function getWeakness(target) { if (target.type === 'mainboss' && target.bossNum) return BOSS_WEAKNESSES[target.bossNum] || 'RAILGUN'; return WEAKNESSES[target.type]; }
        function getDamageMultiplier(weapon, target) { return getWeakness(target) === weapon ? WEAKNESS_MULTIPLIER : 1; }
        
        function switchWeapon(dir) {
            const weapons = ['RAILGUN', 'LASER', 'NOVA', 'SWARM'];
            let idx = weapons.indexOf(currentWeapon);
            if (currentWeapon === 'LASER') { stopLaserSound(); laserActive = false; }
            idx = (idx + dir + 4) % 4;
            currentWeapon = weapons[idx];
            playSound('weaponSwitch');
            updateWeaponButtonDisplay();
            showNotification(WEAPONS[currentWeapon].name + ' LV.' + weaponLevel, WEAPONS[currentWeapon].color);
        }
        
        // ═══════════════════════════════════════
        // GAME OBJECTS
        // ═══════════════════════════════════════
        let playerBullets = [], enemyBullets = [], powerUps = [], particles = [], notifications = [], damageNumbers = [];
        let enemies = [], boss = null;
        const PAWN = 'pawn', KNIGHT = 'knight', BUBBLE_SHOOTER = 'bubble', BOUNCER = 'bouncer', CHARGER = 'charger';
        const keys = { left: false, right: false, special: false };
        
        const TOTAL_WAVES = 24;
        const MAIN_BOSS_WAVES = [8, 12, 16, 20, 24];
        const MINI_BOSS_WAVES = [5, 11, 15, 19, 23];
        const DOUBLE_MINI_WAVES = [15, 19, 23];
        
        // ═══════════════════════════════════════
        // AUDIO
        // ═══════════════════════════════════════
        function initAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (!bgMusic) {
                bgMusic = new Audio('https://raw.githubusercontent.com/enjurogerjung-prog/therabbittest/main/le-cirque-de-jazz-compressed.mp3');
                bgMusic.loop = true;
                bgMusic.volume = 0.15 * MASTER_VOLUME;
            }
        }
        function playSound(type) {
            if (!soundEnabled || !audioCtx) return;
            const osc = audioCtx.createOscillator(), gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;
            const v = MASTER_VOLUME;
            switch(type) {
                case 'shoot': osc.type = 'square'; osc.frequency.setValueAtTime(800, now); osc.frequency.exponentialRampToValueAtTime(200, now + 0.08); gain.gain.setValueAtTime(0.03*v, now); gain.gain.exponentialRampToValueAtTime(0.005*v, now + 0.08); osc.start(now); osc.stop(now + 0.08); break;
                case 'explosion': osc.type = 'sawtooth'; osc.frequency.setValueAtTime(150, now); osc.frequency.exponentialRampToValueAtTime(30, now + 0.25); gain.gain.setValueAtTime(0.06*v, now); gain.gain.exponentialRampToValueAtTime(0.005*v, now + 0.25); osc.start(now); osc.stop(now + 0.25); break;
                case 'playerHit': osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, now); osc.frequency.setValueAtTime(80, now + 0.1); gain.gain.setValueAtTime(0.075*v, now); gain.gain.exponentialRampToValueAtTime(0.005*v, now + 0.2); osc.start(now); osc.stop(now + 0.2); break;
                case 'powerup': osc.type = 'sine'; osc.frequency.setValueAtTime(400, now); osc.frequency.setValueAtTime(800, now + 0.1); osc.frequency.setValueAtTime(1200, now + 0.2); gain.gain.setValueAtTime(0.04*v, now); gain.gain.exponentialRampToValueAtTime(0.005*v, now + 0.25); osc.start(now); osc.stop(now + 0.25); break;
                case 'weaponSwitch': osc.type = 'sine'; osc.frequency.setValueAtTime(600, now); osc.frequency.setValueAtTime(900, now + 0.05); gain.gain.setValueAtTime(0.025*v, now); gain.gain.exponentialRampToValueAtTime(0.005*v, now + 0.08); osc.start(now); osc.stop(now + 0.08); break;
                case 'special': osc.type = 'square'; osc.frequency.setValueAtTime(200, now); osc.frequency.setValueAtTime(800, now + 0.3); gain.gain.setValueAtTime(0.06*v, now); gain.gain.exponentialRampToValueAtTime(0.005*v, now + 0.4); osc.start(now); osc.stop(now + 0.4); break;
            }
        }
        function startLaserSound() { if (!soundEnabled || !audioCtx || laserPlaying) return; laserOsc = audioCtx.createOscillator(); laserGain = audioCtx.createGain(); laserOsc.type = 'sine'; laserOsc.frequency.setValueAtTime(220, audioCtx.currentTime); laserGain.gain.setValueAtTime(0, audioCtx.currentTime); laserGain.gain.linearRampToValueAtTime(0.015*MASTER_VOLUME, audioCtx.currentTime + 0.1); laserOsc.connect(laserGain); laserGain.connect(audioCtx.destination); laserOsc.start(); laserPlaying = true; }
        function stopLaserSound() { if (!laserPlaying || !laserOsc) return; laserGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1); setTimeout(() => { if (laserOsc) { laserOsc.stop(); laserOsc = null; } laserPlaying = false; }, 150); }
        function startMusic() { if (!musicEnabled) return; initAudio(); if (bgMusic) { bgMusic.volume = 0.15 * MASTER_VOLUME; bgMusic.play().catch(e => {}); } }
        function stopMusic() { if (bgMusic) { bgMusic.pause(); } }
        
        // Pause audio when window is hidden/minimized
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                if (bgMusic && !bgMusic.paused) bgMusic.pause();
                if (laserPlaying) stopLaserSound();
            } else {
                if (musicEnabled && gameStarted && !gameOver && !victory && bgMusic) bgMusic.play().catch(e => {});
            }
        });
        
        // ═══════════════════════════════════════
        // PARTICLES & NOTIFICATIONS
        // ═══════════════════════════════════════
        function spawnParticles(x, y, color, count = 10, type = 'normal') {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = type === 'explosion' ? 2 + Math.random() * 4 : 2 + Math.random() * 4;
                particles.push({
                    x, y,
                    dx: Math.cos(angle) * speed,
                    dy: Math.sin(angle) * speed,
                    life: type === 'explosion' ? 20 + Math.random() * 12 : 25 + Math.random() * 15,
                    color,
                    size: type === 'explosion' ? 2 + Math.random() * 3 : 2 + Math.random() * 3,
                    type: type
                });
            }
            // Add extra sparkles for explosions (smaller and fewer)
            if (type === 'explosion') {
                for (let i = 0; i < count / 3; i++) {
                    particles.push({
                        x: x + (Math.random() - 0.5) * 14,
                        y: y + (Math.random() - 0.5) * 14,
                        dx: (Math.random() - 0.5) * 1.5,
                        dy: (Math.random() - 0.5) * 1.5,
                        life: 12 + Math.random() * 10,
                        color: '#fff',
                        size: 0.8 + Math.random() * 1.5,
                        type: 'sparkle'
                    });
                }
            }
        }
        function spawnHitSparkles(x, y, color, isWeakness = false) {
            const count = isWeakness ? 12 : 6;
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = isWeakness ? 4 + Math.random() * 6 : 3 + Math.random() * 5;
                particles.push({
                    x: x + (Math.random() - 0.5) * 12,
                    y: y + (Math.random() - 0.5) * 12,
                    dx: Math.cos(angle) * speed,
                    dy: Math.sin(angle) * speed,
                    life: isWeakness ? 18 : 12,
                    color: isWeakness ? '#ffffff' : color,
                    size: isWeakness ? 4 : 3,
                    type: 'hit'
                });
            }
            // Ring effect for weakness hits
            if (isWeakness) {
                particles.push({
                    x, y,
                    dx: 0, dy: 0,
                    life: 15,
                    color: '#ffffff',
                    size: 5,
                    type: 'ring',
                    maxSize: 30
                });
            }
        }
        function spawnMuzzleFlash(x, y, color) {
            particles.push({
                x, y,
                dx: 0, dy: 0,
                life: 6,
                color: color,
                size: 15,
                type: 'muzzle'
            });
        }
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                if (p.type === 'flash') {
                    p.duration--;
                    if (p.duration <= 0) particles.splice(i, 1);
                } else if (p.type === 'ring') {
                    p.size += 2;
                    p.life--;
                    if (p.life <= 0) particles.splice(i, 1);
                } else if (p.type === 'muzzle') {
                    p.life--;
                    if (p.life <= 0) particles.splice(i, 1);
                } else {
                    p.x += p.dx;
                    p.y += p.dy;
                    p.dy += 0.12;
                    p.dx *= 0.98;
                    p.life--;
                    if (p.life <= 0) particles.splice(i, 1);
                }
            }
        }
        function drawParticles() {
            particles.forEach(p => {
                if (p.type === 'flash') {
                    ctx.fillStyle = `rgba(255,255,255,${p.alpha})`;
                    ctx.fillRect(0, 0, 400, 500);
                } else if (p.type === 'ring') {
                    ctx.globalAlpha = p.life / 15;
                    ctx.strokeStyle = p.color;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (p.type === 'muzzle') {
                    ctx.globalAlpha = p.life / 6;
                    const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
                    grad.addColorStop(0, '#ffffff');
                    grad.addColorStop(0.4, p.color);
                    grad.addColorStop(1, 'transparent');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                } else if (p.type === 'sparkle') {
                    ctx.globalAlpha = Math.min(1, p.life / 10);
                    ctx.fillStyle = p.color;
                    // Draw star shape
                    ctx.beginPath();
                    for (let i = 0; i < 4; i++) {
                        const angle = (i / 4) * Math.PI * 2;
                        const x = p.x + Math.cos(angle) * p.size;
                        const y = p.y + Math.sin(angle) * p.size;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                } else {
                    ctx.globalAlpha = Math.min(1, p.life / 15);
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * (p.life / 25), 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            ctx.globalAlpha = 1;
        }
        function showNotification(text, color = '#fff') { notifications.push({ text, color, y: 220, life: 70, alpha: 1 }); }
        function updateNotifications() { for (let i = notifications.length - 1; i >= 0; i--) { const n = notifications[i]; n.y -= 0.8; n.life--; n.alpha = Math.min(1, n.life / 25); if (n.life <= 0) notifications.splice(i, 1); } }
        function drawNotifications() { ctx.font = 'bold 14px Courier New'; ctx.textAlign = 'center'; notifications.forEach(n => { ctx.globalAlpha = n.alpha; ctx.fillStyle = n.color; ctx.globalAlpha = n.alpha * 0.3; ctx.fillText(n.text, 200, n.y - 1); ctx.fillText(n.text, 200, n.y + 1); ctx.fillText(n.text, 199, n.y); ctx.fillText(n.text, 201, n.y); ctx.globalAlpha = n.alpha; ctx.fillText(n.text, 200, n.y); }); ctx.globalAlpha = 1; }
        
        // ═══════════════════════════════════════
        // DRAWING FUNCTIONS
        // ═══════════════════════════════════════
        function drawPlayer() {
            if (playerInvulnerable && Math.floor(invulnerableTimer / 4) % 2 === 0) return;
            const t = frameTime / 100, flicker = Math.sin(t * 3) * 2, level = weaponLevel;
            const weaponColor = WEAPONS[currentWeapon].color;
            
            ctx.save(); ctx.translate(player.x, player.y);
            
            // ═══ LEVEL-BASED POWER EFFECTS (DBZ STYLE) ═══
            
            // Level 2+: Subtle energy field
            if (level >= 2) {
                const pulseSize = 30 + Math.sin(t * 2) * 5;
                ctx.globalAlpha = 0.08 + level * 0.02;
                const energyGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, pulseSize);
                energyGrad.addColorStop(0, weaponColor);
                energyGrad.addColorStop(1, 'transparent');
                ctx.fillStyle = energyGrad;
                ctx.beginPath();
                ctx.arc(0, 0, pulseSize, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Level 3+: Pulsing aura rings
            if (level >= 3) {
                for (let i = 0; i < level - 2; i++) {
                    const ringSize = 25 + i * 12 + Math.sin(t * 3 + i) * 4;
                    ctx.globalAlpha = 0.15 - i * 0.03;
                    ctx.strokeStyle = weaponColor;
                    ctx.lineWidth = 2 - i * 0.3;
                    ctx.beginPath();
                    ctx.arc(0, 0, ringSize, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            
            // Level 4+: Electric arcs crackling around ship
            if (level >= 4) {
                ctx.globalAlpha = 0.7;
                ctx.strokeStyle = weaponColor;
                ctx.lineWidth = 1.5;
                const arcCount = level - 2;
                for (let i = 0; i < arcCount; i++) {
                    const startAngle = (t * 2 + i * (Math.PI * 2 / arcCount)) % (Math.PI * 2);
                    const arcLength = 15 + level * 3;
                    ctx.beginPath();
                    let px = Math.cos(startAngle) * 18;
                    let py = Math.sin(startAngle) * 18;
                    ctx.moveTo(px, py);
                    for (let j = 0; j < 4; j++) {
                        px += (Math.random() - 0.5) * 12 + Math.cos(startAngle + j * 0.3) * 5;
                        py += (Math.random() - 0.5) * 12 + Math.sin(startAngle + j * 0.3) * 5;
                        ctx.lineTo(px, py);
                    }
                    ctx.stroke();
                }
            }
            
            // Level 5+: Orbiting energy particles
            if (level >= 5) {
                const particleCount = level - 3;
                for (let i = 0; i < particleCount; i++) {
                    const orbitAngle = t * 3 + i * (Math.PI * 2 / particleCount);
                    const orbitRadius = 28 + Math.sin(t * 5 + i) * 5;
                    const px = Math.cos(orbitAngle) * orbitRadius;
                    const py = Math.sin(orbitAngle) * orbitRadius * 0.6;
                    
                    ctx.globalAlpha = 0.8;
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(px, py, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.globalAlpha = 0.4;
                    ctx.fillStyle = weaponColor;
                    ctx.beginPath();
                    ctx.arc(px, py, 6, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Level 6+: Intense energy wisps rising
            if (level >= 6) {
                ctx.globalAlpha = 0.5;
                for (let i = 0; i < 4; i++) {
                    const wispX = (Math.sin(t * 4 + i * 1.5) * 15);
                    const wispY = -20 - ((t * 30 + i * 15) % 40);
                    const wispGrad = ctx.createRadialGradient(wispX, wispY, 0, wispX, wispY, 8);
                    wispGrad.addColorStop(0, weaponColor);
                    wispGrad.addColorStop(1, 'transparent');
                    ctx.fillStyle = wispGrad;
                    ctx.beginPath();
                    ctx.arc(wispX, wispY, 8, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Level 7 (MAX): FULL POWER MODE - DBZ style overflow
            if (level >= 7) {
                // Intense pulsing core
                const maxPulse = Math.sin(t * 6) * 0.3 + 0.7;
                ctx.globalAlpha = 0.3 * maxPulse;
                const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 50);
                coreGrad.addColorStop(0, '#ffffff');
                coreGrad.addColorStop(0.3, weaponColor);
                coreGrad.addColorStop(1, 'transparent');
                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(0, 0, 50 + Math.sin(t * 8) * 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Lightning bolts shooting outward
                ctx.globalAlpha = 0.9;
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                for (let i = 0; i < 6; i++) {
                    const boltAngle = t * 1.5 + i * (Math.PI / 3);
                    ctx.beginPath();
                    let bx = 0, by = 0;
                    ctx.moveTo(bx, by);
                    for (let j = 0; j < 5; j++) {
                        bx += Math.cos(boltAngle) * 10 + (Math.random() - 0.5) * 8;
                        by += Math.sin(boltAngle) * 10 + (Math.random() - 0.5) * 8;
                        ctx.lineTo(bx, by);
                    }
                    ctx.stroke();
                }
                
                // Screaming energy particles
                for (let i = 0; i < 8; i++) {
                    const pAngle = t * 4 + i * (Math.PI / 4);
                    const pDist = 35 + Math.sin(t * 10 + i) * 10;
                    const px = Math.cos(pAngle) * pDist;
                    const py = Math.sin(pAngle) * pDist;
                    ctx.globalAlpha = 0.6;
                    ctx.fillStyle = i % 2 === 0 ? '#ffffff' : weaponColor;
                    ctx.beginPath();
                    ctx.arc(px, py, 2 + Math.random() * 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            ctx.globalAlpha = 1;
            ctx.scale(0.8, 0.8); // 20% smaller visual, hitbox unchanged
            
            // ═══ SHIP BODY ═══
            // Engine flames (grey for monochrome)
            ctx.fillStyle = '#888888'; ctx.beginPath(); ctx.moveTo(-8, 12); ctx.lineTo(-10, 24 + flicker); ctx.lineTo(-6, 12); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(8, 12); ctx.lineTo(10, 24 + flicker); ctx.lineTo(6, 12); ctx.closePath(); ctx.fill();
            ctx.fillStyle = '#cccccc'; ctx.beginPath(); ctx.moveTo(-8, 12); ctx.lineTo(-9, 18 + flicker * 0.5); ctx.lineTo(-7, 12); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(8, 12); ctx.lineTo(9, 18 + flicker * 0.5); ctx.lineTo(7, 12); ctx.closePath(); ctx.fill();
            
            // Main body (monochrome grey)
            ctx.fillStyle = level >= 6 ? '#f0f0f0' : '#e0e0e0'; 
            ctx.strokeStyle = level >= 4 ? weaponColor : '#888'; 
            ctx.lineWidth = level >= 4 ? 2 : 1;
            if (level >= 6) { ctx.shadowColor = weaponColor; ctx.shadowBlur = 15; }
            ctx.beginPath(); ctx.moveTo(0, -12); ctx.lineTo(10, 0); ctx.lineTo(12, 10); ctx.lineTo(6, 14); ctx.lineTo(-6, 14); ctx.lineTo(-12, 10); ctx.lineTo(-10, 0); ctx.closePath(); ctx.fill(); ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Wings (grey)
            ctx.fillStyle = '#a0a0a0'; ctx.beginPath(); ctx.moveTo(-10, 0); ctx.lineTo(-14, 5); ctx.lineTo(-12, 12); ctx.lineTo(-10, 10); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(14, 5); ctx.lineTo(12, 12); ctx.lineTo(10, 10); ctx.closePath(); ctx.fill();
            
            // Ears (grey)
            ctx.fillStyle = '#e8e8e8'; ctx.beginPath(); ctx.moveTo(-5, -10); ctx.quadraticCurveTo(-8, -25, -4, -28); ctx.quadraticCurveTo(-1, -25, -3, -10); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(5, -10); ctx.quadraticCurveTo(8, -25, 4, -28); ctx.quadraticCurveTo(1, -25, 3, -10); ctx.closePath(); ctx.fill();
            ctx.fillStyle = '#c0c0c0'; ctx.beginPath(); ctx.moveTo(-4, -12); ctx.quadraticCurveTo(-6, -22, -4, -24); ctx.quadraticCurveTo(-2, -22, -3, -12); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(4, -12); ctx.quadraticCurveTo(6, -22, 4, -24); ctx.quadraticCurveTo(2, -22, 3, -12); ctx.closePath(); ctx.fill();
            
            // Cockpit with energy glow at high levels
            if (level >= 5) { ctx.shadowColor = weaponColor; ctx.shadowBlur = 10; }
            ctx.fillStyle = weaponColor; ctx.beginPath(); ctx.ellipse(0, -4, 6, 4, 0, 0, Math.PI * 2); ctx.fill(); 
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.ellipse(-2, -5, 2, 1.5, -0.3, 0, Math.PI * 2); ctx.fill();
            
            // Crown at level 5+ (white instead of gold)
            if (level >= 5) { ctx.fillStyle = '#ffffff'; ctx.font = 'bold 12px Arial'; ctx.textAlign = 'center'; ctx.fillText('★', 0, -33); }
            
            // MAX POWER crown enhancement
            if (level >= 7) {
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px Arial';
                ctx.fillText('★', 0, -33);
                ctx.fillStyle = weaponColor;
                ctx.globalAlpha = 0.5 + Math.sin(t * 8) * 0.3;
                ctx.fillText('✦', -10, -28);
                ctx.fillText('✦', 10, -28);
                ctx.globalAlpha = 1;
            }
            
            ctx.restore();
            if (level >= 5) { drawWingman(player.x - 35, player.y + 15, t, -1); drawWingman(player.x + 35, player.y + 15, t, 1); }
        }
        
        function drawWingman(x, y, t, side) {
            ctx.save(); ctx.translate(x, y);
            const level = weaponLevel;
            const weaponColor = WEAPONS[currentWeapon].color;
            
            // Wingman energy aura at high levels
            if (level >= 6) {
                ctx.globalAlpha = 0.3;
                const auraGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 20);
                auraGrad.addColorStop(0, weaponColor);
                auraGrad.addColorStop(1, 'transparent');
                ctx.fillStyle = auraGrad;
                ctx.beginPath();
                ctx.arc(0, 0, 20 + Math.sin(t * 4 + side) * 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Small electric sparks for wingmen at level 7
            if (level >= 7) {
                ctx.globalAlpha = 0.6;
                ctx.strokeStyle = weaponColor;
                ctx.lineWidth = 1;
                for (let i = 0; i < 2; i++) {
                    const sparkAngle = t * 5 + i * Math.PI + side;
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(sparkAngle) * 8, Math.sin(sparkAngle) * 8);
                    ctx.lineTo(Math.cos(sparkAngle) * 15 + (Math.random() - 0.5) * 6, Math.sin(sparkAngle) * 15 + (Math.random() - 0.5) * 6);
                    ctx.stroke();
                }
            }
            
            ctx.globalAlpha = 1;
            ctx.scale(0.55, 0.55);
            const flicker = Math.sin(t * 3 + side) * 2;
            ctx.fillStyle = '#888888'; ctx.beginPath(); ctx.moveTo(-5, 8); ctx.lineTo(-7, 16 + flicker); ctx.lineTo(-3, 8); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(5, 8); ctx.lineTo(7, 16 + flicker); ctx.lineTo(3, 8); ctx.closePath(); ctx.fill();
            ctx.fillStyle = '#c0c0c0'; ctx.strokeStyle = weaponColor; ctx.lineWidth = 1.5; 
            if (level >= 6) { ctx.shadowColor = weaponColor; ctx.shadowBlur = 8; }
            ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(8, 2); ctx.lineTo(10, 10); ctx.lineTo(-10, 10); ctx.lineTo(-8, 2); ctx.closePath(); ctx.fill(); ctx.stroke();
            ctx.shadowBlur = 0;
            ctx.fillStyle = weaponColor; ctx.beginPath(); ctx.ellipse(0, -2, 4, 3, 0, 0, Math.PI * 2); ctx.fill();
            ctx.restore();
        }
        
        function drawShields() { if (shields <= 0) return; const t = frameTime / 400; for (let i = 0; i < shields; i++) { ctx.globalAlpha = 0.3 + Math.sin(t + i) * 0.15; ctx.strokeStyle = '#aaaaaa'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(player.x, player.y, 28 + i * 10, 0, Math.PI * 2); ctx.stroke(); } ctx.globalAlpha = 1; }
        
        function drawPawn(x, y) { ctx.save(); ctx.translate(x, y); const t = frameTime / 100, flicker = Math.sin(t * 4) * 2; ctx.fillStyle = '#666666'; ctx.beginPath(); ctx.moveTo(-4, 10); ctx.lineTo(-5, 16 + flicker); ctx.lineTo(-3, 10); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(4, 10); ctx.lineTo(5, 16 + flicker); ctx.lineTo(3, 10); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#707078'; ctx.beginPath(); ctx.moveTo(-8, 8); ctx.lineTo(-6, 12); ctx.lineTo(6, 12); ctx.lineTo(8, 8); ctx.lineTo(6, 4); ctx.lineTo(-6, 4); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(-7, 5); ctx.quadraticCurveTo(-8, 0, -6, -5); ctx.quadraticCurveTo(0, -12, 6, -5); ctx.quadraticCurveTo(8, 0, 7, 5); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#505058'; ctx.beginPath(); ctx.arc(0, -8, 4, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#ffffff'; ctx.beginPath(); ctx.ellipse(-3, -2, 2.5, 2, -0.2, 0, Math.PI * 2); ctx.ellipse(3, -2, 2.5, 2, 0.2, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#cccccc'; ctx.beginPath(); ctx.arc(-3, -2, 1, 0, Math.PI * 2); ctx.arc(3, -2, 1, 0, Math.PI * 2); ctx.fill(); ctx.restore(); }
        function drawKnight(x, y) { ctx.save(); ctx.translate(x, y); const t = frameTime / 100, flicker = Math.sin(t * 3) * 2; ctx.fillStyle = '#555555'; ctx.beginPath(); ctx.moveTo(-3, 12); ctx.lineTo(-5, 20 + flicker); ctx.lineTo(5, 20 + flicker); ctx.lineTo(3, 12); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#303038'; ctx.fillRect(-12, 8, 6, 6); ctx.fillRect(6, 8, 6, 6); ctx.fillStyle = '#404048'; ctx.fillRect(-10, -4, 20, 14); ctx.fillRect(-10, -10, 5, 6); ctx.fillRect(-2, -10, 5, 6); ctx.fillRect(5, -10, 5, 6); ctx.fillStyle = '#ffffff'; ctx.fillRect(-9, 4, 3, 2); ctx.fillRect(6, 4, 3, 2); ctx.fillStyle = '#ffffff'; ctx.beginPath(); ctx.moveTo(-6, -2); ctx.lineTo(-2, 0); ctx.lineTo(-6, 2); ctx.closePath(); ctx.moveTo(6, -2); ctx.lineTo(2, 0); ctx.lineTo(6, 2); ctx.closePath(); ctx.fill(); ctx.restore(); }
        function drawBubbleShooter(x, y) { ctx.save(); ctx.translate(x, y); const t = frameTime / 100, flicker = Math.sin(t * 3.5) * 2; ctx.strokeStyle = 'rgba(150, 150, 150, 0.3)'; ctx.lineWidth = 1; for (let i = 0; i < 3; i++) { const ringY = ((t * 8 + i * 10) % 30) - 15; ctx.globalAlpha = (1 - Math.abs(ringY) / 15) * 0.4; ctx.beginPath(); ctx.ellipse(0, ringY, 14 - Math.abs(ringY) * 0.3, 4, 0, 0, Math.PI * 2); ctx.stroke(); } ctx.globalAlpha = 1; ctx.fillStyle = '#555555'; ctx.beginPath(); ctx.moveTo(-3, 12); ctx.lineTo(0, 22 + flicker); ctx.lineTo(3, 12); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#909098'; ctx.beginPath(); ctx.moveTo(-8, 8); ctx.lineTo(-6, 14); ctx.lineTo(6, 14); ctx.lineTo(8, 8); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(-8, 8); ctx.quadraticCurveTo(-10, 0, -6, -8); ctx.quadraticCurveTo(0, -16, 6, -8); ctx.quadraticCurveTo(10, 0, 8, 8); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#707078'; ctx.beginPath(); ctx.arc(0, -4, 5, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#ffffff'; ctx.beginPath(); ctx.arc(-1, -5, 2, 0, Math.PI * 2); ctx.fill(); ctx.restore(); }
        function drawBouncer(x, y, enemy) { ctx.save(); ctx.translate(x, y); const t = frameTime / 200, pulse = Math.sin(t * 4) * 2; ctx.globalAlpha = 0.2; ctx.fillStyle = '#888888'; ctx.beginPath(); ctx.arc(0, 0, 18 + pulse, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1; ctx.fillStyle = '#606068'; ctx.beginPath(); ctx.arc(0, 0, 14, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#808088'; ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#ffffff'; ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI * 2); ctx.fill(); ctx.restore(); }
        function drawCharger(x, y, enemy) { ctx.save(); ctx.translate(x, y); const charging = enemy && enemy.charging; if (charging) { ctx.globalAlpha = 0.3; ctx.fillStyle = '#888888'; ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(18, 15); ctx.lineTo(-18, 15); ctx.closePath(); ctx.fill(); ctx.globalAlpha = 1; } ctx.fillStyle = charging ? '#909090' : '#707070'; ctx.beginPath(); ctx.moveTo(0, -15); ctx.lineTo(12, 10); ctx.lineTo(-12, 10); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#999999'; ctx.beginPath(); ctx.arc(0, -8, 4, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = charging ? '#fff' : '#cccccc'; ctx.beginPath(); ctx.arc(-5, 0, 3, 0, Math.PI * 2); ctx.arc(5, 0, 3, 0, Math.PI * 2); ctx.fill(); ctx.restore(); }
        
        function drawMiniBoss(enemy) {
            ctx.save();
            ctx.translate(enemy.x, enemy.y);
            const t = frameTime / 100;
            const bob = Math.sin(t / 10) * 3;
            const isSecond = enemy.type === 'miniboss2';
            
            ctx.translate(0, bob);
            
            // Draw the mecha horse sprite
            if (miniBossSpriteLoaded) {
                const scale = 0.09; // Scale down the large image
                const w = 977 * scale;
                const h = 942 * scale;
                
                ctx.save();
                if (isSecond) ctx.scale(-1, 1); // Mirror second boss
                
                // Tint effect when damaged
                if (enemy.health < enemy.maxHealth * 0.3) {
                    ctx.globalAlpha = 0.7 + Math.sin(t) * 0.3;
                }
                
                ctx.drawImage(miniBossSprite, -w/2, -h/2, w, h);
                ctx.restore();
            } else {
                // Fallback: simple shape (grey)
                ctx.fillStyle = isSecond ? '#505050' : '#707070';
                ctx.beginPath();
                ctx.ellipse(0, 0, 35, 40, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('BOSS', 0, 5);
            }
            
            // HP bar (grey/white)
            if (enemy.health > 0 && enemy.maxHealth) {
                const barWidth = 60;
                ctx.fillStyle = '#333';
                ctx.fillRect(-barWidth/2, 50, barWidth, 6);
                ctx.fillStyle = enemy.health > enemy.maxHealth * 0.3 ? '#ffffff' : '#888888';
                ctx.fillRect(-barWidth/2, 50, barWidth * (enemy.health / enemy.maxHealth), 6);
            }
            ctx.restore();
        }
        
        function drawBoss() {
            if (!boss) return;
            ctx.save(); ctx.translate(boss.x, boss.y);
            const t = frameTime / 100, bossNum = boss.bossNum || 1, healthPercent = boss.health / boss.maxHealth;
            boss.animTimer = (boss.animTimer || 0) + 1;
            const size = BOSS_SIZES[bossNum] || BOSS_SIZES[1];
            const wiggle = Math.sin(boss.animTimer / 15) * 3, bounce = Math.sin(boss.animTimer / 10) * 2;
            
            // Damage flash
            if (healthPercent < 0.3 && Math.sin(boss.animTimer / 2) > 0) ctx.globalAlpha = 0.7;
            
            ctx.save();
            ctx.rotate(wiggle * 0.02);
            ctx.translate(0, bounce);
            
            // Draw sprite if loaded
            if (bossSprites[bossNum] && bossSprites[bossNum].complete && bossSprites[bossNum].naturalWidth > 0) {
                ctx.drawImage(bossSprites[bossNum], -size.w/2, -size.h/2, size.w, size.h);
            } else {
                // Fallback colored rectangle (grey for monochrome)
                ctx.fillStyle = '#606060';
                ctx.fillRect(-size.w/2, -size.h/2, size.w, size.h);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('BOSS ' + bossNum, 0, 5);
            }
            ctx.restore();
            ctx.globalAlpha = 1;
            
            // HP bar (grey/white for monochrome)
            if (boss.health > 0 && boss.maxHealth) {
                const barWidth = Math.max(100, size.w * 0.8), barY = size.h/2 + 10;
                ctx.fillStyle = '#333'; ctx.fillRect(-barWidth/2, barY, barWidth, 8);
                ctx.fillStyle = boss.health > boss.maxHealth * 0.3 ? '#ffffff' : '#888888';
                ctx.fillRect(-barWidth/2, barY, barWidth * healthPercent, 8);
            }
            ctx.restore();
        }
        
        function drawBullets() {
            const t = frameTime / 100;
            
            // PLAYER BULLETS - Enhanced effects
            playerBullets.forEach(b => {
                ctx.save();
                
                if (b.type === 'volt') {
                    // RAILGUN - Electric bolt with lightning effect (20% smaller visuals)
                    const len = (20 + weaponLevel * 3) * 0.8;
                    
                    // Outer glow
                    ctx.globalAlpha = 0.3;
                    ctx.fillStyle = '#00ffff';
                    ctx.beginPath();
                    ctx.ellipse(b.x, b.y, (8 + weaponLevel) * 0.8, len/2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Electric arcs (jagged lines)
                    ctx.globalAlpha = 0.7;
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        let px = b.x, py = b.y - len/2;
                        ctx.moveTo(px, py);
                        for (let j = 0; j < 4; j++) {
                            px += (Math.random() - 0.5) * 12;
                            py += len/4;
                            ctx.lineTo(px, py);
                        }
                        ctx.stroke();
                    }
                    
                    // Core bolt
                    ctx.globalAlpha = 1;
                    const grad = ctx.createLinearGradient(b.x, b.y - len/2, b.x, b.y + len/2);
                    grad.addColorStop(0, '#ffffff');
                    grad.addColorStop(0.3, '#00ffff');
                    grad.addColorStop(0.7, '#0088ff');
                    grad.addColorStop(1, '#004488');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.moveTo(b.x, b.y - len/2);
                    ctx.lineTo(b.x + 3.2, b.y);
                    ctx.lineTo(b.x, b.y + len/2);
                    ctx.lineTo(b.x - 3.2, b.y);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Bright tip
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(b.x, b.y - len/2, 2.4, 0, Math.PI * 2);
                    ctx.fill();
                    
                } else if (b.type === 'seeker') {
                    // SWARM - Homing missiles with trails (20% smaller visuals)
                    
                    // Smoke trail
                    if (b.trail && b.trail.length > 1) {
                        ctx.globalAlpha = 0.4;
                        ctx.strokeStyle = '#88ff88';
                        ctx.lineWidth = 2.4;
                        ctx.beginPath();
                        b.trail.forEach((p, i) => {
                            ctx.globalAlpha = (i / b.trail.length) * 0.4;
                            if (i === 0) ctx.moveTo(p.x, p.y);
                            else ctx.lineTo(p.x, p.y);
                        });
                        ctx.stroke();
                    }
                    
                    // Thruster glow
                    ctx.globalAlpha = 0.5;
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.ellipse(b.x, b.y + 6.4, 3.2, 6.4 + Math.random() * 3.2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Missile body
                    ctx.globalAlpha = 1;
                    const angle = Math.atan2(b.dy, b.dx);
                    ctx.translate(b.x, b.y);
                    ctx.rotate(angle + Math.PI/2);
                    
                    // Body gradient
                    const missileGrad = ctx.createLinearGradient(-3.2, -6.4, 3.2, -6.4);
                    missileGrad.addColorStop(0, '#004400');
                    missileGrad.addColorStop(0.5, '#00ff00');
                    missileGrad.addColorStop(1, '#004400');
                    ctx.fillStyle = missileGrad;
                    ctx.fillRect(-2.4, -6.4, 4.8, 9.6);
                    
                    // Nose cone
                    ctx.fillStyle = '#88ff88';
                    ctx.beginPath();
                    ctx.moveTo(0, -9.6);
                    ctx.lineTo(2.4, -6.4);
                    ctx.lineTo(-2.4, -6.4);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Fins
                    ctx.fillStyle = '#006600';
                    ctx.fillRect(-4, 1.6, 1.6, 3.2);
                    ctx.fillRect(2.4, 1.6, 1.6, 3.2);
                    
                    // Targeting glow when locked
                    if (b.target) {
                        ctx.fillStyle = '#ff0000';
                        ctx.beginPath();
                        ctx.arc(0, -8, 1.6, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                } else if (b.type === 'spread') {
                    // NOVA - Energy orbs with rings (20% smaller visuals)
                    const size = (5 + weaponLevel * 0.5) * 0.8;
                    
                    // Outer ring pulse
                    ctx.globalAlpha = 0.3;
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 1.6;
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, size + 3.2 + Math.sin(t * 3) * 1.6, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Glow
                    ctx.globalAlpha = 0.5;
                    const orbGrad = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, size + 2.4);
                    orbGrad.addColorStop(0, '#ffffff');
                    orbGrad.addColorStop(0.4, '#ffff00');
                    orbGrad.addColorStop(1, 'transparent');
                    ctx.fillStyle = orbGrad;
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, size + 2.4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Core
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Hot center
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, size * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    
                } else {
                    // Default bullet (20% smaller)
                    ctx.fillStyle = b.color || '#00ffff';
                    ctx.fillRect(b.x - 1.6, b.y - 4.8, 3.2, 9.6);
                }
                
                ctx.restore();
            });
            
            // ENEMY BULLETS
            enemyBullets.forEach(b => {
                if (b.isBubble) {
                    // Pink bubble
                    ctx.globalAlpha = 0.4;
                    ctx.fillStyle = '#ff88aa';
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, (b.size || 10) + 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.globalAlpha = 0.7;
                    ctx.fillStyle = '#cc2255';
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.size || 10, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = 'rgba(255,255,255,0.6)';
                    ctx.beginPath();
                    ctx.arc(b.x - 3, b.y - 3, 3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (b.isOrangeBall) {
                    ctx.fillStyle = '#ffcc00';
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, (b.size || 14) + 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ff8800';
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.size || 14, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Regular enemy bullet
                    ctx.fillStyle = '#ff4400';
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            // LASER BEAM - Enhanced multi-layer effect
            if (laserActive && currentWeapon === 'LASER') {
                const level = weaponLevel;
                const baseWidth = 6 + level * 3;
                const beamHeight = player.y - 10;
                
                // Outer energy field
                ctx.globalAlpha = 0.1;
                ctx.fillStyle = '#ff00ff';
                ctx.fillRect(player.x - baseWidth * 2, 0, baseWidth * 4, beamHeight);
                
                // Electric side arcs
                ctx.globalAlpha = 0.4;
                ctx.strokeStyle = '#ff88ff';
                ctx.lineWidth = 1;
                for (let side = -1; side <= 1; side += 2) {
                    ctx.beginPath();
                    for (let y = 0; y < beamHeight; y += 20) {
                        const xOff = Math.sin(t * 5 + y * 0.1) * (baseWidth * 0.8);
                        if (y === 0) ctx.moveTo(player.x + side * baseWidth + xOff, y);
                        else ctx.lineTo(player.x + side * baseWidth + xOff, y);
                    }
                    ctx.stroke();
                }
                
                // Main beam layers
                ctx.globalAlpha = 0.2;
                ctx.fillStyle = '#ff00ff';
                ctx.fillRect(player.x - baseWidth * 1.5, 0, baseWidth * 3, beamHeight);
                
                ctx.globalAlpha = 0.4;
                ctx.fillStyle = '#ff44ff';
                ctx.fillRect(player.x - baseWidth, 0, baseWidth * 2, beamHeight);
                
                ctx.globalAlpha = 0.6;
                ctx.fillStyle = '#ff88ff';
                ctx.fillRect(player.x - baseWidth * 0.6, 0, baseWidth * 1.2, beamHeight);
                
                ctx.globalAlpha = 0.8;
                ctx.fillStyle = '#ffccff';
                ctx.fillRect(player.x - baseWidth * 0.3, 0, baseWidth * 0.6, beamHeight);
                
                // White hot core
                ctx.globalAlpha = 1;
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(player.x - 2, 0, 4, beamHeight);
                
                // Energy pulses traveling up the beam
                for (let i = 0; i < 5; i++) {
                    const pulseY = beamHeight - ((t * 15 + i * (beamHeight / 5)) % beamHeight);
                    ctx.globalAlpha = 0.7;
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.ellipse(player.x, pulseY, baseWidth * 1.2, 6, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Muzzle flash at player
                ctx.globalAlpha = 0.6 + Math.sin(t * 10) * 0.3;
                const muzzleGrad = ctx.createRadialGradient(player.x, player.y - 15, 0, player.x, player.y - 15, 25);
                muzzleGrad.addColorStop(0, '#ffffff');
                muzzleGrad.addColorStop(0.5, '#ff88ff');
                muzzleGrad.addColorStop(1, 'transparent');
                ctx.fillStyle = muzzleGrad;
                ctx.beginPath();
                ctx.arc(player.x, player.y - 15, 25, 0, Math.PI * 2);
                ctx.fill();
                
                // Wingman lasers at level 5+
                if (level >= 5) {
                    const wingW = baseWidth * 0.5;
                    [-35, 35].forEach(offset => {
                        ctx.globalAlpha = 0.15;
                        ctx.fillStyle = '#ff00ff';
                        ctx.fillRect(player.x + offset - wingW * 1.5, 0, wingW * 3, player.y + 5);
                        ctx.globalAlpha = 0.3;
                        ctx.fillStyle = '#ff88ff';
                        ctx.fillRect(player.x + offset - wingW, 0, wingW * 2, player.y + 5);
                        ctx.globalAlpha = 0.6;
                        ctx.fillStyle = '#ffccff';
                        ctx.fillRect(player.x + offset - wingW * 0.4, 0, wingW * 0.8, player.y + 5);
                    });
                }
                ctx.globalAlpha = 1;
            }
        }
        
        function drawPowerUps() {
            powerUps.forEach(p => {
                ctx.save(); ctx.translate(p.x, p.y);
                const t = frameTime / 200, bob = Math.sin(t + p.x) * 3; ctx.translate(0, bob);
                if (p.type === 'UPGRADE') { ctx.fillStyle = 'rgba(200, 200, 200, 0.3)'; ctx.fillRect(-10, -10, 20, 20); ctx.fillStyle = '#cccccc'; ctx.fillRect(-8, -8, 16, 16); ctx.fillStyle = '#fff'; ctx.fillRect(-2, -6, 4, 12); ctx.fillRect(-6, -2, 12, 4); }
                else if (p.type === 'HEART') { ctx.fillStyle = '#aaaaaa'; ctx.beginPath(); ctx.arc(-4, -2, 6, 0, Math.PI * 2); ctx.arc(4, -2, 6, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.moveTo(-10, 0); ctx.lineTo(0, 12); ctx.lineTo(10, 0); ctx.closePath(); ctx.fill(); }
                else if (p.type === 'BOMB') { ctx.fillStyle = 'rgba(180, 180, 180, 0.3)'; ctx.beginPath(); ctx.arc(0, 0, 14, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#b0b0b0'; ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#fff'; ctx.font = 'bold 12px Courier New'; ctx.textAlign = 'center'; ctx.fillText('B', 0, 5); }
                else if (p.type === 'SHIELD') { ctx.strokeStyle = '#aaaaaa'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI * 2); ctx.stroke(); ctx.strokeStyle = 'rgba(170, 170, 170, 0.3)'; ctx.lineWidth = 6; ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI * 2); ctx.stroke(); }
                ctx.restore();
            });
        }
        
        // ═══════════════════════════════════════
        // WEAPON FIRING (STRONGER AT MAX LEVEL!)
        // ═══════════════════════════════════════
        let lastFireTime = 0;
        
        function fireWeapon() {
            const weapon = WEAPONS[currentWeapon];
            if (frameTime - lastFireTime < weapon.fireRate) return;
            lastFireTime = frameTime;
            const level = weaponLevel;
            
            // Muzzle flash for all weapons
            spawnMuzzleFlash(player.x, player.y - 15, weapon.color);
            
            switch(currentWeapon) {
                case 'RAILGUN':
                    // Damage scales (50% reduced): 1.75, 2.5, 3.25, 4, 4.75, 5.5, 6.25
                    const dmg = 1.75 + level * 0.75;
                    playerBullets.push({ x: player.x, y: player.y - 20, dx: 0, dy: -1, speed: 16 + level * 0.3, damage: dmg, type: 'volt', color: '#00ffff' });
                    // Side shots at level 2+
                    if (level >= 2) {
                        const sideSpread = 0.06 + (level - 2) * 0.01;
                        playerBullets.push({ x: player.x - 12, y: player.y - 12, dx: -sideSpread, dy: -1, speed: 15, damage: dmg * 0.6, type: 'volt', color: '#00dddd' });
                        playerBullets.push({ x: player.x + 12, y: player.y - 12, dx: sideSpread, dy: -1, speed: 15, damage: dmg * 0.6, type: 'volt', color: '#00dddd' });
                    }
                    // Extra side shots at level 4+
                    if (level >= 4) {
                        playerBullets.push({ x: player.x - 20, y: player.y - 5, dx: -0.12, dy: -1, speed: 14, damage: dmg * 0.5, type: 'volt', color: '#00cccc' });
                        playerBullets.push({ x: player.x + 20, y: player.y - 5, dx: 0.12, dy: -1, speed: 14, damage: dmg * 0.5, type: 'volt', color: '#00cccc' });
                    }
                    // Wingman shots at level 5+
                    if (level >= 5) {
                        playerBullets.push({ x: player.x - 35, y: player.y + 5, dx: 0, dy: -1, speed: 14, damage: dmg * 0.4, type: 'volt', color: '#00aaaa' });
                        playerBullets.push({ x: player.x + 35, y: player.y + 5, dx: 0, dy: -1, speed: 14, damage: dmg * 0.4, type: 'volt', color: '#00aaaa' });
                        spawnMuzzleFlash(player.x - 35, player.y, '#00ffff');
                        spawnMuzzleFlash(player.x + 35, player.y, '#00ffff');
                    }
                    addScreenShake(1, 2); // Slight recoil
                    playSound('shoot'); break;
                    
                case 'NOVA':
                    // Spread count: 3, 4, 4, 5, 5, 6, 7
                    const spreadCount = 3 + Math.floor(level / 2);
                    const spreadAngle = 0.15 + level * 0.02;
                    const novaDmg = 1 + level * 0.25; // 50% reduced
                    for (let i = 0; i < spreadCount; i++) {
                        const angle = -Math.PI/2 + (i - (spreadCount-1)/2) * spreadAngle;
                        playerBullets.push({ x: player.x, y: player.y - 15, dx: Math.cos(angle), dy: Math.sin(angle), speed: 10 + level * 0.5, damage: novaDmg, type: 'spread', color: '#ffff00' });
                    }
                    // Wingman nova at level 5+
                    if (level >= 5) {
                        const wingCount = 2 + Math.floor((level - 5) / 2);
                        [-35, 35].forEach(offset => {
                            for (let i = 0; i < wingCount; i++) {
                                const angle = -Math.PI/2 + (i - (wingCount-1)/2) * 0.2;
                                playerBullets.push({ x: player.x + offset, y: player.y + 5, dx: Math.cos(angle), dy: Math.sin(angle), speed: 9, damage: novaDmg * 0.5, type: 'spread', color: '#dddd00' });
                            }
                            spawnMuzzleFlash(player.x + offset, player.y, '#ffff00');
                        });
                    }
                    addScreenShake(1.5, 3);
                    playSound('shoot'); break;
                    
                case 'SWARM':
                    // Missile count: 2, 2, 3, 3, 4, 4, 5
                    const missileCount = 2 + Math.floor(level / 2);
                    const swarmDmg = 2 + level * 0.7;
                    for (let i = 0; i < missileCount; i++) {
                        playerBullets.push({ x: player.x + (i - (missileCount-1)/2) * 12, y: player.y - 10, dx: (Math.random() - 0.5) * 0.4, dy: -0.8, speed: 3, maxSpeed: 8 + level * 0.5, acceleration: 0.3 + level * 0.02, turnSpeed: 0.12 + level * 0.01, damage: swarmDmg, type: 'seeker', color: '#00ff00', target: null, trail: [] });
                    }
                    // Wingman missiles at level 5+
                    if (level >= 5) {
                        const wingMissiles = 1 + Math.floor((level - 5) / 2);
                        [-35, 35].forEach(offset => {
                            for (let j = 0; j < wingMissiles; j++) {
                                playerBullets.push({ x: player.x + offset, y: player.y + 5, dx: (Math.random() - 0.5) * 0.3, dy: -0.8, speed: 3, maxSpeed: 8, acceleration: 0.28, turnSpeed: 0.11, damage: swarmDmg * 0.5, type: 'seeker', color: '#00cc00', target: null, trail: [] });
                            }
                            spawnMuzzleFlash(player.x + offset, player.y, '#00ff00');
                        });
                    }
                    addScreenShake(1, 2);
                    playSound('shoot'); break;
            }
        }
        
        // ═══════════════════════════════════════
        // SPECIAL ATTACK
        // ═══════════════════════════════════════
        function useSpecialAttack() {
            if (specialAttacks <= 0 || !specialReady) return;
            specialAttacks--; specialReady = false;
            setTimeout(() => specialReady = true, 500);
            document.getElementById('specialCount').textContent = '×' + specialAttacks;
            if (specialAttacks <= 0) document.getElementById('specialBtn').disabled = true;
            playSound('special');
            enemyBullets = [];
            for (let i = enemies.length - 1; i >= 0; i--) { enemies[i].health -= 30; spawnParticles(enemies[i].x, enemies[i].y, '#ffffff', 6); if (enemies[i].health <= 0) handleEnemyDeath(enemies[i], i); }
            if (boss) { boss.health -= 80; spawnParticles(boss.x, boss.y, '#ffffff', 12); if (boss.health <= 0) handleBossDeath(); }
            particles.push({ type: 'flash', alpha: 0.7, duration: 12 });
            triggerScreenShake(15, 20);
            showNotification('BOMB!', '#ffffff');
        }
        
        // ═══════════════════════════════════════
        // ENEMY/BOSS DEATH HANDLERS (FIXED!)
        // ═══════════════════════════════════════
        function handleEnemyDeath(enemy, index) {
            score += enemy.points || 10;
            const isMiniBoss = enemy.type === 'miniboss' || enemy.type === 'miniboss2';
            const isBigEnemy = enemy.type === BOUNCER || enemy.type === CHARGER;
            
            // Smaller white/cyan explosions (distinct from orange enemy projectiles)
            const particleCount = isMiniBoss ? 14 : isBigEnemy ? 8 : 5;
            spawnParticles(enemy.x, enemy.y, '#ffffff', particleCount, 'explosion');
            
            // Screen shake based on enemy size
            if (isMiniBoss) {
                addScreenShake(12, 18);
                particles.push({ type: 'flash', alpha: 0.4, duration: 8 });
                spawnDamageNumber(enemy.x, enemy.y, enemy.points || 400, true);
            } else if (isBigEnemy) {
                addScreenShake(5, 8);
                spawnDamageNumber(enemy.x, enemy.y, enemy.points || 25, false);
            } else {
                addScreenShake(2, 4);
            }
            
            playSound('explosion');
            if (enemy.hasPowerUp) spawnPowerUp(enemy.x, enemy.y);
            const wasMiniBoss = enemy.type === 'miniboss' || enemy.type === 'miniboss2';
            enemies.splice(index, 1);
            if (wasMiniBoss && !enemies.some(e => e.type === 'miniboss' || e.type === 'miniboss2')) {
                bossActive = false;
                advanceWave();
            }
        }
        
        function handleBossDeath() {
            if (!boss) return;
            score += boss.points || 1000;
            
            // Epic explosion
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    spawnParticles(boss.x + (Math.random()-0.5)*60, boss.y + (Math.random()-0.5)*40, '#ffffff', 15, 'explosion');
                    addScreenShake(8, 10);
                }, i * 100);
            }
            
            spawnDamageNumber(boss.x, boss.y, boss.points || 1000, true);
            playSound('explosion');
            particles.push({ type: 'flash', alpha: 0.9, duration: 15 });
            addScreenShake(25, 35);
            showNotification('BOSS DEFEATED!', '#ffffff');
            boss = null;
            bossActive = false;
            advanceWave();
        }
        
        function advanceWave() {
            if (waveTransitioning) return;
            wave++;
            if (wave > TOTAL_WAVES) { showVictory(); }
            else { waveTransitioning = true; setTimeout(() => initWave(wave), 1500); }
        }
        
        function spawnPowerUp(x, y) { const rand = Math.random(); let type = rand < 0.48 ? 'UPGRADE' : rand < 0.73 ? 'HEART' : rand < 0.87 ? 'BOMB' : 'SHIELD'; powerUps.push({ x, y, type, dy: 1.2 }); }
        function collectPowerUp(p) { playSound('powerup'); switch(p.type) { case 'UPGRADE': if (weaponLevel < MAX_WEAPON_LEVEL) { weaponLevel++; showNotification('POWER UP!', '#00ffff'); } else { score += 500; showNotification('+500', '#ffd700'); } break; case 'HEART': lives++; showNotification('+1 LIFE', '#ff4444'); break; case 'BOMB': specialAttacks = Math.min(specialAttacks + 1, 5); document.getElementById('specialCount').textContent = '×' + specialAttacks; document.getElementById('specialBtn').disabled = false; showNotification('+BOMB', '#ffaa00'); break; case 'SHIELD': shields = Math.min(shields + 1, 3); showNotification('+SHIELD', '#00aaff'); break; } updateUI(); }
        
        // ═══════════════════════════════════════
        // WAVE INIT (3X ENEMY HP!)
        // ═══════════════════════════════════════
        function initWave(waveNum) {
            enemies = []; boss = null; bossActive = false; waveTransitioning = false;
            if (MAIN_BOSS_WAVES.includes(waveNum)) { mainBossLevel++; spawnMainBoss(mainBossLevel); }
            else if (MINI_BOSS_WAVES.includes(waveNum)) { spawnMiniBoss(DOUBLE_MINI_WAVES.includes(waveNum)); }
            else { spawnRegularWave(waveNum); }
            showNotification('WAVE ' + waveNum, '#ffffff');
        }
        
        function spawnMainBoss(level) {
            bossActive = true;
            const isFinalBoss = level === 5;
            const health = (250 + level * 100) * (isFinalBoss ? 6 : 3); // 3X HP! (6X for final boss)
            const size = BOSS_SIZES[level] || BOSS_SIZES[1];
            boss = { x: 200, y: 90, width: size.w * 0.6, height: size.h * 0.6, health, maxHealth: health, type: 'mainboss', bossNum: level, points: 1500 + level * 500, fireTimer: 0, moveDir: 1, phase: 0, animTimer: 0 };
            playSound('explosion');
            showNotification('MAIN BOSS!', '#ff0000');
        }
        
        function spawnMiniBoss(isDouble) {
            bossActive = true;
            const count = isDouble ? 2 : 1;
            for (let i = 0; i < count; i++) {
                const health = (100 + wave * 4) * 3; // 3X HP!
                enemies.push({ x: isDouble ? (i === 0 ? 120 : 280) : 200, y: 70, width: 70, height: 70, health, maxHealth: health, type: i === 0 ? 'miniboss' : 'miniboss2', points: 400, fireTimer: Math.random() * 30, moveDir: i === 0 ? 1 : -1 });
            }
            showNotification(isDouble ? 'TWIN BOSSES!' : 'MINI BOSS!', '#e8707e');
        }
        
        function spawnRegularWave(waveNum) {
            const difficulty = Math.floor(waveNum / 4);
            const enemyCount = 5 + waveNum + difficulty * 2;
            for (let i = 0; i < enemyCount; i++) {
                const row = Math.floor(i / 6), col = i % 6;
                const x = 55 + col * 55, y = 55 + row * 50;
                let type = PAWN;
                const rand = Math.random();
                if (waveNum >= 17 && rand < 0.15) type = CHARGER;
                else if (waveNum >= 13 && rand < 0.2) type = BOUNCER;
                else if (waveNum >= 6 && rand < 0.25) type = BUBBLE_SHOOTER;
                else if (waveNum >= 3 && rand < 0.35) type = KNIGHT;
                
                let health, points;
                switch(type) {
                    case PAWN: health = (6 + difficulty * 2) * 3; points = 10; break; // 3X HP!
                    case KNIGHT: health = (12 + difficulty * 4) * 3; points = 25; break;
                    case BUBBLE_SHOOTER: health = (10 + difficulty * 2) * 3; points = 30; break;
                    case BOUNCER: health = (30 + difficulty * 6) * 3; points = 50; break;
                    case CHARGER: health = (24 + difficulty * 4) * 3; points = 40; break;
                }
                enemies.push({ x, y, type, health, points, width: type === BOUNCER ? 28 : 22, height: type === BOUNCER ? 28 : 26, moveDir: i % 2 === 0 ? 1 : -1, fireTimer: Math.random() * 100, hasPowerUp: Math.random() < 0.18, dx: type === BOUNCER ? (Math.random() - 0.5) * 3 : 0, dy: type === BOUNCER ? Math.random() * 2 + 1 : 0, charging: false, chargeTimer: 0 });
            }
        }
        
        // ═══════════════════════════════════════
        // UPDATE (with all freeze fixes)
        // ═══════════════════════════════════════
        function update(dt) {
            if (!gameStarted || gameOver || victory) return;
            
            const speed = 5.5;
            if (keys.left) player.x -= speed;
            if (keys.right) player.x += speed;
            player.x = Math.max(20, Math.min(380, player.x));
            
            if (playerInvulnerable) { invulnerableTimer--; if (invulnerableTimer <= 0) playerInvulnerable = false; }
            if (screenShake > 0) screenShake--;
            
            if (currentWeapon === 'LASER') { if (!laserActive) { laserActive = true; startLaserSound(); } }
            else { if (laserActive) { laserActive = false; stopLaserSound(); } fireWeapon(); }
            
            if (keys.special) { useSpecialAttack(); keys.special = false; }
            
            updateStars(); updateParticles(); updateNotifications(); updateDamageNumbers();
            
            // Update player bullets
            for (let i = playerBullets.length - 1; i >= 0; i--) {
                const b = playerBullets[i];
                if (b.type === 'seeker') {
                    if (b.speed < b.maxSpeed) b.speed += b.acceleration;
                    if (!b.target || (b.target.health !== undefined && b.target.health <= 0)) {
                        b.target = null; let bestDist = Infinity;
                        enemies.forEach(e => { const d = Math.hypot(e.x - b.x, e.y - b.y); if (d < bestDist && e.y < b.y + 60) { bestDist = d; b.target = e; } });
                        if (boss) { const d = Math.hypot(boss.x - b.x, boss.y - b.y); if (d < bestDist) b.target = boss; }
                    }
                    if (b.target) { const angle = Math.atan2(b.target.y - b.y, b.target.x - b.x), currentAngle = Math.atan2(b.dy, b.dx); let diff = angle - currentAngle; while (diff > Math.PI) diff -= Math.PI * 2; while (diff < -Math.PI) diff += Math.PI * 2; const newAngle = currentAngle + Math.sign(diff) * Math.min(Math.abs(diff), b.turnSpeed); b.dx = Math.cos(newAngle); b.dy = Math.sin(newAngle); }
                    b.trail.push({ x: b.x, y: b.y }); if (b.trail.length > 8) b.trail.shift();
                }
                b.x += (b.dx || 0) * b.speed; b.y += b.dy * b.speed;
                if (b.y < -20 || b.y > 520 || b.x < -20 || b.x > 420) playerBullets.splice(i, 1);
            }
            
            // Update enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                if (e.type === 'miniboss' || e.type === 'miniboss2') {
                    e.x += e.moveDir * 1.8 * gameSpeed; if (e.x < 60 || e.x > 340) e.moveDir *= -1;
                    e.fireTimer++;
                    if (e.fireTimer > 50) { e.fireTimer = 0; const angle = Math.atan2(player.y - e.y, player.x - e.x); enemyBullets.push({ x: e.x, y: e.y + 25, dx: Math.cos(angle) * 3.5, dy: Math.sin(angle) * 3.5 }); if (Math.random() < 0.3) { enemyBullets.push({ x: e.x - 20, y: e.y + 15, dx: 0, dy: 4 }); enemyBullets.push({ x: e.x + 20, y: e.y + 15, dx: 0, dy: 4 }); } }
                } else if (e.type === BOUNCER) {
                    e.x += e.dx * gameSpeed; e.y += e.dy * gameSpeed;
                    if (e.x < 25 || e.x > 375) e.dx *= -1;
                    if (e.y < 50 || e.y > 280) e.dy *= -1;
                } else if (e.type === CHARGER) {
                    e.chargeTimer++;
                    if (e.charging) { e.y += 9 * gameSpeed; if (e.y > 520) { e.y = 50; e.charging = false; e.chargeTimer = 0; } }
                    else { e.x += e.moveDir * 1.2 * gameSpeed; if (e.x < 35 || e.x > 365) e.moveDir *= -1; if (e.chargeTimer > 100 && Math.abs(e.x - player.x) < 40) e.charging = true; }
                } else {
                    e.x += e.moveDir * 0.6 * gameSpeed; if (e.x < 35 || e.x > 365) e.moveDir *= -1;
                    e.fireTimer++;
                    const fireRate = e.type === BUBBLE_SHOOTER ? 100 : 150;
                    if (e.fireTimer > fireRate && Math.random() < 0.025) { e.fireTimer = 0; if (e.type === BUBBLE_SHOOTER) { enemyBullets.push({ x: e.x, y: e.y + 15, dx: 0, dy: 2.5, isBubble: true, size: 12 }); } else { enemyBullets.push({ x: e.x, y: e.y + 14, dx: (player.x - e.x) * 0.012, dy: 3.5 }); } }
                }
                
                // Bullet collision
                for (let bi = playerBullets.length - 1; bi >= 0; bi--) {
                    const b = playerBullets[bi];
                    if (Math.abs(b.x - e.x) < e.width/2 + 6 && Math.abs(b.y - e.y) < e.height/2 + 6) {
                        const weapon = b.type === 'volt' ? 'RAILGUN' : b.type === 'seeker' ? 'SWARM' : b.type === 'spread' ? 'NOVA' : 'RAILGUN';
                        const mult = getDamageMultiplier(weapon, e);
                        const damage = b.damage * mult;
                        e.health -= damage;
                        
                        // Enhanced hit feedback
                        const isCrit = mult > 1;
                        spawnHitSparkles(b.x, b.y, isCrit ? '#ffff00' : WEAPONS[weapon].color, isCrit);
                        if (isCrit) addScreenShake(2, 3);
                        
                        // Damage number for bigger hits
                        if (damage >= 3 || isCrit) {
                            spawnDamageNumber(e.x, e.y - 10, damage, isCrit);
                        }
                        
                        playerBullets.splice(bi, 1);
                        if (e.health <= 0) { handleEnemyDeath(e, i); break; }
                    }
                }
                
                // Player collision
                if (!playerInvulnerable && enemies[i] && Math.abs(e.x - player.x) < e.width/2 + 12 && Math.abs(e.y - player.y) < e.height/2 + 12) loseLife();
            }
            
            // LASER DAMAGE (balanced)
            if (laserActive && currentWeapon === 'LASER') {
                const laserWidth = 6 + weaponLevel * 3;
                const baseDamage = 0.35 + weaponLevel * 0.12;
                
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const e = enemies[i];
                    if (Math.abs(e.x - player.x) < laserWidth * 1.2 + e.width/2 && e.y < player.y) {
                        const mult = getDamageMultiplier('LASER', e);
                        e.health -= baseDamage * mult;
                        if (Math.random() < 0.1) spawnHitSparkles(e.x, e.y, mult > 1 ? '#ffff00' : '#ff00ff');
                        if (e.health <= 0) handleEnemyDeath(e, i);
                    }
                }
                
                if (weaponLevel >= 5) {
                    const wingLaserWidth = laserWidth * 0.4;
                    [-35, 35].forEach(offset => {
                        for (let i = enemies.length - 1; i >= 0; i--) {
                            const e = enemies[i];
                            if (Math.abs(e.x - (player.x + offset)) < wingLaserWidth + e.width/2 && e.y < player.y + 15) {
                                const mult = getDamageMultiplier('LASER', e);
                                e.health -= baseDamage * 0.3 * mult;
                                if (e.health <= 0) handleEnemyDeath(e, i);
                            }
                        }
                    });
                }
                
                if (boss && Math.abs(boss.x - player.x) < laserWidth * 1.2 + boss.width/2) {
                    const mult = getDamageMultiplier('LASER', boss);
                    boss.health -= baseDamage * 0.7 * mult;
                    if (Math.random() < 0.06) spawnHitSparkles(boss.x + (Math.random()-0.5)*30, boss.y + (Math.random()-0.5)*20, '#ff00ff');
                    if (boss.health <= 0) handleBossDeath();
                }
                
                if (boss && weaponLevel >= 5) {
                    const wingLaserWidth = laserWidth * 0.4;
                    [-35, 35].forEach(offset => {
                        if (boss && Math.abs(boss.x - (player.x + offset)) < wingLaserWidth + boss.width/2) {
                            const mult = getDamageMultiplier('LASER', boss);
                            boss.health -= baseDamage * 0.2 * mult;
                        }
                    });
                    if (boss && boss.health <= 0) handleBossDeath();
                }
            }
            
            // Update boss
            if (boss) {
                boss.x += boss.moveDir * 2.2 * gameSpeed;
                if (boss.x < 90 || boss.x > 310) boss.moveDir *= -1;
                boss.fireTimer++;
                if (boss.fireTimer > 35) {
                    boss.fireTimer = 0;
                    const pattern = Math.floor(Math.random() * 4);
                    if (pattern === 0) { const angle = Math.atan2(player.y - boss.y, player.x - boss.x); enemyBullets.push({ x: boss.x, y: boss.y + boss.height/2, dx: Math.cos(angle) * 4.5, dy: Math.sin(angle) * 4.5 }); }
                    else if (pattern === 1) { for (let i = -2; i <= 2; i++) enemyBullets.push({ x: boss.x, y: boss.y + boss.height/2, dx: i * 1.8, dy: 4.5 }); }
                    else if (pattern === 2) { enemyBullets.push({ x: boss.x, y: boss.y + boss.height/2, dx: 0, dy: 3, isBubble: true, size: 16 }); }
                    else { enemyBullets.push({ x: boss.x - 25, y: boss.y + boss.height/2, dx: -1, dy: 4 }); enemyBullets.push({ x: boss.x + 25, y: boss.y + boss.height/2, dx: 1, dy: 4 }); }
                }
                
                for (let bi = playerBullets.length - 1; bi >= 0; bi--) {
                    const b = playerBullets[bi];
                    if (Math.abs(b.x - boss.x) < boss.width/2 + 8 && Math.abs(b.y - boss.y) < boss.height/2 + 8) {
                        const weapon = b.type === 'volt' ? 'RAILGUN' : b.type === 'seeker' ? 'SWARM' : b.type === 'spread' ? 'NOVA' : 'RAILGUN';
                        const mult = getDamageMultiplier(weapon, boss);
                        boss.health -= b.damage * mult;
                        spawnHitSparkles(b.x, b.y, mult > 1 ? '#ffff00' : WEAPONS[weapon].color);
                        playerBullets.splice(bi, 1);
                        if (boss.health <= 0) { handleBossDeath(); break; }
                    }
                }
            }
            
            // Update enemy bullets
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const b = enemyBullets[i];
                b.x += b.dx || 0; b.y += b.dy || 3.5;
                if (b.y > 520 || b.y < -20 || b.x < -20 || b.x > 420) { enemyBullets.splice(i, 1); continue; }
                if (!playerInvulnerable) {
                    const hitSize = b.isBubble ? (b.size || 10) + 8 : b.isOrangeBall ? (b.size || 14) + 6 : 12;
                    if (Math.abs(b.x - player.x) < hitSize && Math.abs(b.y - player.y) < hitSize) { enemyBullets.splice(i, 1); loseLife(); }
                }
            }
            
            // Pop bubbles
            for (let bi = playerBullets.length - 1; bi >= 0; bi--) {
                const b = playerBullets[bi];
                for (let ei = enemyBullets.length - 1; ei >= 0; ei--) {
                    const eb = enemyBullets[ei];
                    if (eb.isBubble && Math.abs(b.x - eb.x) < (eb.size || 10) + 6 && Math.abs(b.y - eb.y) < (eb.size || 10) + 6) { spawnHitSparkles(eb.x, eb.y, '#ff3366'); enemyBullets.splice(ei, 1); score += 5; break; }
                }
            }
            
            // Update power-ups
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const p = powerUps[i]; p.y += p.dy;
                if (Math.abs(p.x - player.x) < 22 && Math.abs(p.y - player.y) < 22) { collectPowerUp(p); powerUps.splice(i, 1); continue; }
                if (p.y > 520) powerUps.splice(i, 1);
            }
            
            // Check wave complete
            if (!bossActive && !waveTransitioning && enemies.length === 0 && !boss) advanceWave();
            
            updateUI();
        }
        
        // ═══════════════════════════════════════
        // DRAW
        // ═══════════════════════════════════════
        function draw() {
            ctx.save();
            // Screen shake
            updateScreenShake();
            ctx.translate(screenShake.x, screenShake.y);
            
            ctx.fillStyle = '#050510'; ctx.fillRect(0, 0, 400, 500);
            drawStars();
            enemies.forEach((e, i) => {
                if (e.type === PAWN) drawPawn(e.x, e.y);
                else if (e.type === KNIGHT) drawKnight(e.x, e.y);
                else if (e.type === BUBBLE_SHOOTER) drawBubbleShooter(e.x, e.y);
                else if (e.type === BOUNCER) drawBouncer(e.x, e.y, e);
                else if (e.type === CHARGER) drawCharger(e.x, e.y, e);
                else if (e.type === 'miniboss' || e.type === 'miniboss2') drawMiniBoss(e);
                if (e.hasPowerUp) { ctx.fillStyle = '#ffd700'; ctx.beginPath(); ctx.arc(e.x, e.y - e.height, 4, 0, Math.PI * 2); ctx.fill(); }
                if ((e.type === BOUNCER || e.type === CHARGER) && e.health > 0) { const maxHp = e.type === BOUNCER ? 72 : 56; ctx.fillStyle = '#333'; ctx.fillRect(e.x - 12, e.y - 22, 24, 4); ctx.fillStyle = e.health > maxHp * 0.3 ? '#0f0' : '#f00'; ctx.fillRect(e.x - 12, e.y - 22, 24 * Math.min(1, e.health / maxHp), 4); }
            });
            if (boss) drawBoss();
            drawPlayer(); drawShields(); drawBullets(); drawPowerUps(); drawParticles(); drawDamageNumbers(); drawNotifications();
            if (bossActive) { ctx.fillStyle = MAIN_BOSS_WAVES.includes(wave) ? '#ffffff' : '#cccccc'; ctx.font = 'bold 13px Courier New'; ctx.textAlign = 'center'; ctx.fillText(MAIN_BOSS_WAVES.includes(wave) ? '⚔ MAIN BOSS ⚔' : DOUBLE_MINI_WAVES.includes(wave) ? '⚔ TWIN BOSSES ⚔' : '⚔ MINI BOSS ⚔', 200, 28); }
            ctx.restore();
        }
        
        function gameLoop(timestamp) { frameTime = timestamp; update(timestamp - lastTime); lastTime = timestamp; draw(); requestAnimationFrame(gameLoop); }
        function triggerScreenShake(intensity, duration) { addScreenShake(intensity, duration); }
        
        function loseLife() {
            if (playerInvulnerable) return;
            if (shields > 0) { shields--; showNotification('SHIELD LOST', '#00aaff'); spawnParticles(player.x, player.y, '#00aaff', 8); triggerScreenShake(6, 12); playSound('playerHit'); updateUI(); return; }
            lives--;
            if (weaponLevel > 1) { weaponLevel--; showNotification('POWER DOWN', '#ff8800'); }
            spawnParticles(player.x, player.y, '#e8707e', 12); triggerScreenShake(14, 22); playSound('playerHit');
            particles.push({ type: 'flash', alpha: 0.5, duration: 10 });
            playerInvulnerable = true; invulnerableTimer = 70;
            if (lives <= 0) { stopMusic(); showGameOver(); } else showNotification('DAMAGE!', '#ff4444');
            updateUI();
        }
        
        function updateUI() {
            document.getElementById('score').textContent = score;
            let hearts = '♥'.repeat(Math.min(lives, 10)); if (lives > 10) hearts += '+' + (lives - 10);
            document.getElementById('livesDisplay').innerHTML = hearts;
            const powerBar = document.getElementById('powerBar'), powerLabel = document.getElementById('powerLabel');
            powerBar.style.width = (weaponLevel / MAX_WEAPON_LEVEL * 100) + '%';
            if (weaponLevel >= 5) { powerBar.classList.add('maxed'); powerLabel.className = 'rabbit-mode'; powerLabel.textContent = 'RABBIT MODE'; }
            else { powerBar.classList.remove('maxed'); powerLabel.className = 'power-label'; powerLabel.textContent = 'PWR'; }
        }
        
        function showGameOver() { gameOver = true; stopMusic(); stopLaserSound(); laserActive = false; document.getElementById('finalScore').textContent = score; document.getElementById('gameOverScreen').classList.remove('hidden'); document.getElementById('weaponHudLeft').classList.add('hidden'); document.getElementById('weaponHudRight').classList.add('hidden'); }
        function showVictory() { victory = true; stopMusic(); stopLaserSound(); laserActive = false; document.getElementById('victoryScore').textContent = score; if (newGamePlusLevel > 0) document.getElementById('continueBtn').textContent = 'NG+' + (newGamePlusLevel + 1) + '?'; document.getElementById('victoryScreen').classList.remove('hidden'); document.getElementById('weaponHudLeft').classList.add('hidden'); document.getElementById('weaponHudRight').classList.add('hidden'); }
        
        function continueToNewGamePlus() {
            newGamePlusLevel++; victory = false; gameSpeed += 0.18; wave = 1; mainBossLevel = 0; waveTransitioning = false;
            playerBullets = []; enemyBullets = []; powerUps = []; particles = []; damageNumbers = [];
            specialAttacks = Math.min(specialAttacks + 2, 5);
            document.getElementById('specialCount').textContent = '×' + specialAttacks;
            document.getElementById('specialBtn').disabled = false;
            document.getElementById('victoryScreen').classList.add('hidden');
            document.getElementById('weaponHudLeft').classList.remove('hidden');
            document.getElementById('weaponHudRight').classList.remove('hidden');
            showNotification('CYCLE ' + newGamePlusLevel + ' INITIATED', '#ff00ff');
            startMusic(); initWave(1); updateUI();
        }
        
        function restartGame() {
            gameStarted = true; gameOver = false; victory = false; waveTransitioning = false;
            score = 0; lives = 5; wave = 1; gameSpeed = 1.0; newGamePlusLevel = 0; mainBossLevel = 0;
            currentWeapon = 'RAILGUN'; weaponLevel = 1; specialAttacks = 3; specialReady = true; shields = 0;
            player.x = 200; playerBullets = []; enemyBullets = []; powerUps = []; particles = []; notifications = []; damageNumbers = [];
            playerInvulnerable = false; invulnerableTimer = 0; laserActive = false; bossActive = false; boss = null;
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('victoryScreen').classList.add('hidden');
            document.getElementById('weaponHudLeft').classList.remove('hidden');
            document.getElementById('weaponHudRight').classList.remove('hidden');
            document.getElementById('specialCount').textContent = '×3';
            document.getElementById('specialBtn').disabled = false;
            startMusic(); updateUI(); updateWeaponButtonDisplay(); initWave(1);
        }
        
        function startGame() {
            if (gameStarted) return;
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('weaponHudLeft').classList.remove('hidden');
            document.getElementById('weaponHudRight').classList.remove('hidden');
            gameStarted = true; lives = 5; currentWeapon = 'RAILGUN'; weaponLevel = 1;
            initAudio(); startMusic(); initWave(1); updateUI(); updateWeaponButtonDisplay();
        }
        
        // ═══════════════════════════════════════
        // INPUT
        // ═══════════════════════════════════════
        document.addEventListener('keydown', (e) => {
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
            if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
            if (e.code === 'Space') { e.preventDefault(); if (!gameStarted) startGame(); else keys.special = true; }
            if (e.code === 'Escape') toggleSettingsMenu();
            const wmap = { Digit1: 'RAILGUN', Digit2: 'LASER', Digit3: 'NOVA', Digit4: 'SWARM' };
            if (wmap[e.code]) { if (currentWeapon === 'LASER' && wmap[e.code] !== 'LASER') { stopLaserSound(); laserActive = false; } currentWeapon = wmap[e.code]; playSound('weaponSwitch'); updateWeaponButtonDisplay(); showNotification(WEAPONS[currentWeapon].name + ' LV.' + weaponLevel, WEAPONS[currentWeapon].color); }
            if (e.code === 'KeyQ') switchWeapon(-1);
            if (e.code === 'KeyE') switchWeapon(1);
        });
        document.addEventListener('keyup', (e) => { if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false; if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false; if (e.code === 'Space') keys.special = false; });
        
        document.getElementById('startScreen').addEventListener('click', startGame);
        document.getElementById('startScreen').addEventListener('touchstart', (e) => { e.preventDefault(); startGame(); }, { passive: false });
        
        const leftBtn = document.getElementById('leftBtn'), rightBtn = document.getElementById('rightBtn'), specialBtn = document.getElementById('specialBtn');
        function setupMoveBtn(btn, key) {
            btn.addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                if (!gameStarted) { startGame(); return; }
                keys[key] = true; btn.classList.add('active'); 
            }, { passive: false });
            btn.addEventListener('touchend', () => { keys[key] = false; btn.classList.remove('active'); });
            btn.addEventListener('touchcancel', () => { keys[key] = false; btn.classList.remove('active'); });
            btn.addEventListener('mousedown', () => { if (!gameStarted) startGame(); else keys[key] = true; });
            btn.addEventListener('mouseup', () => keys[key] = false);
            btn.addEventListener('mouseleave', () => keys[key] = false);
        }
        setupMoveBtn(leftBtn, 'left'); setupMoveBtn(rightBtn, 'right');
        specialBtn.addEventListener('touchstart', (e) => { e.preventDefault(); if (!gameStarted) startGame(); else keys.special = true; }, { passive: false });
        specialBtn.addEventListener('click', () => { if (!gameStarted) startGame(); else keys.special = true; });
        
        const weaponButtons = document.querySelectorAll('.weapon-btn');
        function selectWeapon(weaponKey) { if (currentWeapon === 'LASER' && weaponKey !== 'LASER') { stopLaserSound(); laserActive = false; } currentWeapon = weaponKey; playSound('weaponSwitch'); updateWeaponButtonDisplay(); showNotification(WEAPONS[currentWeapon].name + ' LV.' + weaponLevel, WEAPONS[currentWeapon].color); }
        function updateWeaponButtonDisplay() { weaponButtons.forEach(btn => { const weapon = btn.dataset.weapon, statusEl = btn.querySelector('.weapon-status'); if (weapon === currentWeapon) { btn.classList.add('active'); statusEl.textContent = 'ACTIVE'; } else { btn.classList.remove('active'); statusEl.textContent = 'READY'; } }); }
        weaponButtons.forEach(btn => { btn.addEventListener('touchstart', (e) => { e.preventDefault(); if (!gameStarted) startGame(); else selectWeapon(btn.dataset.weapon); }, { passive: false }); btn.addEventListener('click', () => { if (!gameStarted) startGame(); else selectWeapon(btn.dataset.weapon); }); });
        
        let menuOpen = false;
        function toggleSettingsMenu() { menuOpen = !menuOpen; document.getElementById('settingsMenu').classList.toggle('open', menuOpen); }
        document.getElementById('settingsBtn').addEventListener('click', toggleSettingsMenu);
        document.getElementById('musicToggle').addEventListener('click', function() { musicEnabled = !musicEnabled; this.classList.toggle('active', musicEnabled); if (musicEnabled && gameStarted && !gameOver && !victory) startMusic(); else stopMusic(); });
        document.getElementById('soundToggle').addEventListener('click', function() { soundEnabled = !soundEnabled; this.classList.toggle('active', soundEnabled); if (!soundEnabled) stopLaserSound(); });
        
        document.body.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
        
        updateWeaponButtonDisplay();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
